{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":0,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/vuex.png","path":"images/vuex.png","modified":0,"renderable":1},{"_id":"themes/next/source/images/avatar.png","path":"images/avatar.png","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":0,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":0,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":0,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":0,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"78e69af1d9b1c038edd1259e5a746a0524b61502","modified":1538064073558},{"_id":"themes/next/.DS_Store","hash":"710121816cde2278701b84f03d0157829d433ec2","modified":1538055675398},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1537973434815},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1537973434815},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1537973434816},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1537973434817},{"_id":"themes/next/.javascript_ignore","hash":"8a224b381155f10e6eb132a4d815c5b52962a9d1","modified":1537973434817},{"_id":"themes/next/.travis.yml","hash":"d60d4a5375fea23d53b2156b764a99b2e56fa660","modified":1537973434817},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1537973434817},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1537973434817},{"_id":"themes/next/LICENSE","hash":"f293bcfcdc06c0b77ba13570bb8af55eb5c059fd","modified":1537973434818},{"_id":"themes/next/README.md","hash":"8ce60ce578963eb4e1eb5e33e1efc2fc4779af9c","modified":1537973434818},{"_id":"themes/next/README.cn.md","hash":"2c766b3369ed477bce134a5450dab45bef161504","modified":1537973434818},{"_id":"themes/next/gulpfile.coffee","hash":"031bffc483e417b20e90eceb6cf358e7596d2e69","modified":1537973434819},{"_id":"themes/next/_config.yml","hash":"8f51be9ea83f1219a6a71a2a1eb4a7a4ecd4e84d","modified":1538056014581},{"_id":"themes/next/bower.json","hash":"0674f11d3d514e087a176da0e1d85c2286aa5fba","modified":1537973434818},{"_id":"themes/next/package.json","hash":"036d3a1346203d2f1a3958024df7f74e7ac07bfe","modified":1537973434836},{"_id":"themes/next/.gitignore","hash":"0b5c2ffd41f66eb1849d6426ba8cf9649eeed329","modified":1537973434817},{"_id":"source/categories/index.md","hash":"4d67701b670f4fe8c079177e8f8ae5a0e4022f45","modified":1537975721177},{"_id":"source/_posts/1-JS-zuoyongyu.md","hash":"2f2224d8de76900903436e5be538bd2a8f5e9ae7","modified":1554042225208},{"_id":"source/_posts/1-Node-introduction.md","hash":"5ca7f094c4a9cf579de8f215ec63a2c7e9cf3297","modified":1547381673765},{"_id":"source/_posts/1-ts.md","hash":"2514658ba9fcea1495deffd8cc50af6d50796e82","modified":1552092876204},{"_id":"source/_posts/2-JS-tishenghebibao.md","hash":"81f4597daaa82487d8abcbc53a5393855a50828b","modified":1554126504012},{"_id":"source/_posts/2-ts-primitive-data-type.md","hash":"393624505521bfadad2bc25fde9a87327924202a","modified":1552093844471},{"_id":"source/_posts/3-JS-this.md","hash":"219e36552026ccd7cc0601e440ec89f71c7d9d21","modified":1554203607854},{"_id":"source/_posts/3-ts-any.md","hash":"7599d27fd33bcc373b82daec43101b2a477d80ef","modified":1552094396750},{"_id":"source/_posts/4-ts-interfaces.md","hash":"0858dc6143cf92b61563f6f607174c034931541f","modified":1552096093038},{"_id":"source/_posts/async.md","hash":"d63212197c66de54020b468d40f503e247e73db9","modified":1546005973803},{"_id":"source/_posts/axios.md","hash":"085920416d2e79b380b4e8f1235833b272ccc6bf","modified":1555511805709},{"_id":"source/_posts/blog-construct.md","hash":"592488f12e777599b072849a5732f82e28920706","modified":1538319211805},{"_id":"source/_posts/blog-start.md","hash":"913e91c5285ac8ba532d2e086d5c72e0d8ccee9f","modified":1538141814089},{"_id":"source/_posts/ele-upload.md","hash":"f0dcbfa43e7d2a68c952ee24b2c701f25efe074e","modified":1554819579298},{"_id":"source/_posts/h5-pay.md","hash":"fe8bc5bc0659b764bbea725bce6e3777f8fa9e12","modified":1539097310246},{"_id":"source/_posts/js-shangxiawen.md","hash":"623fad27d56effc7cf15f48f1a7d1ff5b79100c4","modified":1546529238058},{"_id":"source/_posts/moment.md","hash":"df3561dbfc2886da4e7f7d18712a729287324676","modified":1539179044946},{"_id":"source/_posts/react-router.md","hash":"caa4549500f30d56839d5d4ea65841551579ded0","modified":1551012706531},{"_id":"source/_posts/react.md","hash":"51bc809801a6544ecf226e8672383188a04731bf","modified":1554042453175},{"_id":"source/_posts/vue-router-history.md","hash":"972f1a333c84b1cc0cb2b56414674da945d29b31","modified":1539699840013},{"_id":"source/_posts/vue-vuex.md","hash":"78adc146f1e9f7744d11e97efe9cccad5eb7519f","modified":1539097349600},{"_id":"source/_posts/weChat-component.md","hash":"31083e5295350878da6ece83024b5d6bd3fbf001","modified":1541343622487},{"_id":"source/_posts/weChat-wx-request.md","hash":"aa84efe57a43931b20243971daa5d915f8f66cbc","modified":1544020636678},{"_id":"source/tags/index.md","hash":"033f665b059cc8d96920a8c010c44aeac9f8f9ee","modified":1537976577594},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1537973434807},{"_id":"themes/next/.git/config","hash":"bf7d1df65cf34d0f25a7184a58c37a09f72e4be7","modified":1537973434809},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1537972960471},{"_id":"themes/next/.git/packed-refs","hash":"69237944e31c16fe545d1f47b0b1e5b1d99660da","modified":1537973434806},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"3b5eafd32abb718e56ccf8d1cee0607ad8ce611d","modified":1537973434816},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"50d48c47162817a3810a9d9ad51104e83947419a","modified":1537973434816},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"902f627155a65099e0a37842ff396a58d0dc306f","modified":1537973434816},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1537973434817},{"_id":"themes/next/languages/de.yml","hash":"057e7df11ddeb1c8c15a5d7c5ff29430d725ec6b","modified":1537973434819},{"_id":"themes/next/languages/default.yml","hash":"44ef3f26917f467459326c2c8be2f73e4d947f35","modified":1537973434819},{"_id":"themes/next/languages/en.yml","hash":"7e680d9bb8f3a3a9d1ba1c9d312b3d257183dded","modified":1537973434819},{"_id":"themes/next/languages/fr-FR.yml","hash":"7e4eb7011b8feee641cfb11c6e73180b0ded1c0f","modified":1537973434820},{"_id":"themes/next/languages/id.yml","hash":"b5de1ea66dd9ef54cac9a1440eaa4e3f5fc011f5","modified":1537973434820},{"_id":"themes/next/languages/it.yml","hash":"aa595f2bda029f73ef7bfa104b4c55c3f4e9fb4c","modified":1537973434820},{"_id":"themes/next/languages/ja.yml","hash":"3c76e16fd19b262864475faa6854b718bc08c4d8","modified":1537973434820},{"_id":"themes/next/languages/ko.yml","hash":"ea5b46056e73ebcee121d5551627af35cbffc900","modified":1537973434820},{"_id":"themes/next/languages/nl-NL.yml","hash":"edca4f3598857dbc3cbf19ed412213329b6edd47","modified":1537973434820},{"_id":"themes/next/languages/pt.yml","hash":"44b61f2d085b827b507909a0b8f8ce31c6ef5d04","modified":1537973434821},{"_id":"themes/next/languages/pt-BR.yml","hash":"b1694ae766ed90277bcc4daca4b1cfa19cdcb72b","modified":1537973434821},{"_id":"themes/next/languages/ru.yml","hash":"98ec6f0b7183282e11cffc7ff586ceb82400dd75","modified":1537973434821},{"_id":"themes/next/languages/vi.yml","hash":"fd08d3c8d2c62965a98ac420fdaf95e54c25d97c","modified":1537973434821},{"_id":"themes/next/languages/zh-hk.yml","hash":"9396f41ae76e4fef99b257c93c7354e661f6e0fa","modified":1537973434821},{"_id":"themes/next/languages/zh-Hans.yml","hash":"16ef56d0dea94638de7d200984c90ae56f26b4fe","modified":1537974518684},{"_id":"themes/next/languages/zh-tw.yml","hash":"50b71abb3ecc0686f9739e179e2f829cd074ecd9","modified":1537973434822},{"_id":"themes/next/layout/_layout.swig","hash":"da0929166674ea637e0ad454f85ad0d7bac4aff2","modified":1537973434822},{"_id":"themes/next/.git/index","hash":"f26e0b4792a5c348e7b2f074a8463593c544b66b","modified":1537973434906},{"_id":"themes/next/layout/archive.swig","hash":"f0a8225feafd971419837cdb4bcfec98a4a59b2f","modified":1537973434834},{"_id":"themes/next/layout/category.swig","hash":"4472255f4a3e3dd6d79201523a9526dcabdfbf18","modified":1537973434835},{"_id":"themes/next/layout/index.swig","hash":"783611349c941848a0e26ee2f1dc44dd14879bd1","modified":1537973434835},{"_id":"themes/next/layout/page.swig","hash":"969caaee05bdea725e99016eb63d810893a73e99","modified":1537973434835},{"_id":"themes/next/layout/post.swig","hash":"b3589a8e46288a10d20e41c7a5985d2493725aec","modified":1537973434835},{"_id":"themes/next/layout/schedule.swig","hash":"d86f8de4e118f8c4d778b285c140474084a271db","modified":1537973434835},{"_id":"themes/next/layout/tag.swig","hash":"7e0a7d7d832883eddb1297483ad22c184e4368de","modified":1537973434836},{"_id":"themes/next/scripts/merge-configs.js","hash":"81e86717ecfb775986b945d17f0a4ba27532ef07","modified":1537973434836},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1537973434836},{"_id":"themes/next/source/.DS_Store","hash":"b8e5951c497e1060bfccf7be197be3bad8cb1885","modified":1538055675401},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1537973434905},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1537973434905},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1537973434905},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1537973434858},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1537972960473},{"_id":"themes/next/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1537972960473},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1537972960474},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1537972960474},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1537972960473},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1537972960473},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1537972960474},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1537972960473},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1537972960474},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1537972960471},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1537972960475},{"_id":"themes/next/.git/logs/HEAD","hash":"0686ba9cec3724b947e1cf00d68d9715e7b59616","modified":1537973434808},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1537972960472},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"31322a7f57936cf2dc62e824af5490da5354cf02","modified":1537973434822},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"665a928604f99d2ba7dc4a4a9150178229568cc6","modified":1537973434822},{"_id":"themes/next/layout/_macro/post.swig","hash":"446a35a2cd389f8cfc3aa38973a9b44ad0740134","modified":1537973434823},{"_id":"themes/next/layout/_macro/reward.swig","hash":"56e8d8556cf474c56ae1bef9cb7bbd26554adb07","modified":1537973434823},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"6a54c3c85ff6b19d275827a327abbf4bd99b2ebf","modified":1537973434823},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"39852700e4084ecccffa6d4669168e5cc0514c9e","modified":1537973434823},{"_id":"themes/next/layout/_partials/comments.swig","hash":"4a6f5b1792b2e5262b7fdab9a716b3108e2f09c7","modified":1537973434823},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1537973434822},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1537973434822},{"_id":"themes/next/layout/_partials/footer.swig","hash":"c4d6181f5d3db5365e622f78714af8cc58d7a45e","modified":1537973434824},{"_id":"themes/next/layout/_partials/head.swig","hash":"6b94fe8f3279daea5623c49ef4bb35917ba57510","modified":1537973434824},{"_id":"themes/next/layout/_partials/header.swig","hash":"ed042be6252848058c90109236ec988e392d91d4","modified":1537973434824},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"1efd925d34a5d4ba2dc0838d9c86ba911e705fc9","modified":1537973434825},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1537973434825},{"_id":"themes/next/layout/_partials/search.swig","hash":"9dbd378e94abfcb3f864a5b8dbbf18d212ca2ee0","modified":1537973434825},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1537973434826},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1537973434826},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"a266f96ad06ee87bdeae6e105a4b53cd587bbd04","modified":1537973434827},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1537973434832},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"7c04a42319d728be356746363aff8ea247791d24","modified":1537973434833},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1537973434833},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"5fe0447cc88a5a63b530cf0426f93c4634811876","modified":1537973434833},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"fc93b1a7e6aed0dddb1f3910142b48d8ab61174e","modified":1537973434833},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1537973434833},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1ddb2336a1a19b47af3017047012c01ec5f54529","modified":1537973434833},{"_id":"themes/next/scripts/tags/button.js","hash":"d023f10a00077f47082b0517e2ad666e6e994f60","modified":1537973434837},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1537973434837},{"_id":"themes/next/scripts/tags/exturl.js","hash":"8d7e60f60779bde050d20fd76f6fdc36fc85e06d","modified":1537973434837},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1537973434837},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1537973434837},{"_id":"themes/next/scripts/tags/label.js","hash":"2f8f41a7316372f0d1ed6b51190dc4acd3e16fff","modified":1537973434837},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"eeeabede68cf263de9e6593ecf682f620da16f0a","modified":1537973434837},{"_id":"themes/next/scripts/tags/note.js","hash":"64de4e9d01cf3b491ffc7d53afdf148ee5ad9779","modified":1537973434838},{"_id":"themes/next/scripts/tags/tabs.js","hash":"5786545d51c38e8ca38d1bfc7dd9e946fc70a316","modified":1537973434838},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1537973434858},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1537973434858},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1537973434859},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1537973434859},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1537973434859},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1537973434859},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1537973434859},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1537973434860},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1537973434860},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1537973434860},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1537973434860},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1537973434861},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1537973434861},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1537973434861},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1537973434861},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1537973434861},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1537973434861},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1537973434862},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1537973434862},{"_id":"themes/next/source/images/vuex.png","hash":"4fb73c3495849d5ac2ac80546a8431d563a7da45","modified":1538923212775},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1537973434827},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1537973434827},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1537973434852},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1537973434852},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1537973434853},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1537973434858},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1537973434858},{"_id":"themes/next/source/images/avatar.png","hash":"49c05a1efe4a4508b560a58574706f15a8a9f5d5","modified":1538055591270},{"_id":"themes/next/.git/refs/heads/master","hash":"7999da428ebb87e5a2b27315d8d5123c1ccdfaa5","modified":1537973434808},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1537973434824},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1537973434824},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1537973434825},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1537973434825},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1537973434825},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1537973434825},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1537973434826},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1537973434826},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"048fd5e98149469f8c28c21ba3561a7a67952c9b","modified":1537973434826},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1537973434826},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1537973434827},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1537973434827},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"98df9d72e37dd071e882f2d5623c9d817815b139","modified":1537973434828},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1537973434828},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1537973434828},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"18e7bef8923d83ea42df6c97405e515a876cede4","modified":1537973434828},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1537973434829},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"a234c5cd1f75ca5731e814d0dbb92fdcf9240d1b","modified":1537973434829},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"1cd01c6e92ab1913d48e556a92bb4f28b6dc4996","modified":1537973434829},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"5d9943d74cc2e0a91badcf4f755c6de77eab193a","modified":1537973434829},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"5e9bb24c750b49513d9a65799e832f07410002ac","modified":1537973434829},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"fc65b9c98a0a8ab43a5e7aabff6c5f03838e09c8","modified":1537973434830},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1537973434830},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"0ddc94ed4ba0c19627765fdf1abc4d8efbe53d5a","modified":1537973434830},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"c3971fd154d781088e1cc665035f8561a4098f4c","modified":1537973434830},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"0e3378f7c39b2b0f69638290873ede6b6b6825c0","modified":1537973434831},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"c316758546dc9ba6c60cb4d852c17ca6bb6d6724","modified":1537973434831},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1537973434831},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"10160daceaa6f1ecf632323d422ebe2caae49ddf","modified":1537973434831},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"aa0629277d751c55c6d973e7691bf84af9b17a60","modified":1537973434832},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1537973434831},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"8a2e393d2e49f7bf560766d8a07cd461bf3fce4f","modified":1537973434832},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"fcabbb241f894c9a6309c44e126cf3e8fea81fd4","modified":1537973434832},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"8b6650f77fe0a824c8075b2659e0403e0c78a705","modified":1537973434832},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"c747fb5c6b1f500e8f0c583e44195878b66e4e29","modified":1537973434834},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"385c066af96bee30be2459dbec8aae1f15d382f5","modified":1537973434834},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1537973434834},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1537973434834},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1537973434852},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1537973434852},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"9ab65361ba0a12a986edd103e56492644c2db0b8","modified":1537973434852},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"82f9055955920ed88a2ab6a20ab02169abb2c634","modified":1537973434853},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"99fbb4686ea9a3e03a4726ed7cf4d8f529034452","modified":1537973434857},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1537973434858},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"f29165e36489a87ba32d17dddfd2720d84e3f3ec","modified":1537973434858},{"_id":"themes/next/source/css/_variables/base.styl","hash":"29c261fa6b4046322559074d75239c6b272fb8a3","modified":1537973434858},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1537973434862},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"b172f697ed339a24b1e80261075232978d164c35","modified":1537973434862},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"034bc8113e0966fe2096ba5b56061bbf10ef0512","modified":1537973434863},{"_id":"themes/next/source/js/src/exturl.js","hash":"e42e2aaab7bf4c19a0c8e779140e079c6aa5c0b1","modified":1537973434863},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1537973434863},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1537973434863},{"_id":"themes/next/source/js/src/motion.js","hash":"754b294394f102c8fd9423a1789ddb1201677898","modified":1537973434864},{"_id":"themes/next/source/js/src/post-details.js","hash":"a13f45f7aa8291cf7244ec5ba93907d119c5dbdd","modified":1537973434864},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"09dc828cbf5f31158ff6250d2bf7c3cde6365c67","modified":1537973434864},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1537973434864},{"_id":"themes/next/source/js/src/utils.js","hash":"9b1325801d27213083d1487a12b1a62b539ab6f8","modified":1537973434865},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1537973434872},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"ff5915eb2596e890a2fc6697c864f861a1995ec0","modified":1537973434872},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1537973434869},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1537973434872},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1537973434873},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1537973434876},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1537973434876},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1537973434876},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1537973434876},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1537973434878},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1537973434878},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1537973434878},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1537973434878},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1537973434889},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"9885fd9bea5e7ebafc5b1de9d17be5e106248d96","modified":1537973434892},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"3ef0020a1815ca6151ea4886cd0d37421ae3695c","modified":1537973434892},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1537973434890},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1537973434891},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1537973434890},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1537973434891},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1537973434891},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1537973434891},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1537973434893},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1537973434893},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1537973434893},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1537973434893},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1537973434893},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1537973434893},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1537973434893},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1537973434894},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1537973434894},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1537973434894},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1537973434894},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1537973434895},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"9944dfb7814b911090e96446cea4d36e2b487234","modified":1537973434895},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"dce4a3b65f8bf958f973690caa7ec4952f353b0c","modified":1537973434896},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"d8ea241a53c135a650f7335d2b6982b899fd58a9","modified":1537973434896},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"d968cba6b3a50b3626a02d67b544f349d83b147c","modified":1537973434896},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1537973434895},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1537973434901},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1537973434904},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1537973434904},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1537973434904},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1537973434901},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1537973434877},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"c39d37278c1e178838732af21bd26cd0baeddfe0","modified":1537973434892},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1537973434890},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1537973434807},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"0686ba9cec3724b947e1cf00d68d9715e7b59616","modified":1537973434808},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1537973434833},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1537973434834},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"4719ce717962663c5c33ef97b1119a0b3a4ecdc3","modified":1537973434838},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1537973434838},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1537973434838},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1537973434838},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1537973434839},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1537973434841},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1537973434845},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1537973434850},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"f7c44b0ee46cf2cf82a4c9455ba8d8b55299976f","modified":1537973434850},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"9c25c75311e1bd4d68df031d3f2ae6d141a90766","modified":1537973434850},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"47a46583a1f3731157a3f53f80ed1ed5e2753e8e","modified":1537973434851},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1537973434851},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1537973434851},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1537973434851},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"18c3336ee3d09bd2da6a876e1336539f03d5a973","modified":1537973434853},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1537973434853},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1537973434854},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1537973434854},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1537973434854},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"3b25edfa187d1bbbd0d38b50dd013cef54758abf","modified":1537973434854},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1537973434854},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1537973434854},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1537973434855},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1537973434855},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4aac01962520d60b03b23022ab601ad4bd19c08c","modified":1537973434855},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1537973434856},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1537973434856},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"c4ed249798296f60bda02351fe6404fb3ef2126f","modified":1537973434856},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5b93958239d3d2bf9aeaede44eced2434d784462","modified":1537973434856},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"215de948be49bcf14f06d500cef9f7035e406a43","modified":1537973434856},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1537973434857},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9d16fa3c14ed76b71229f022b63a02fd0f580958","modified":1537973434857},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1537973434857},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"8050a5b2683d1d77238c5762b6bd89c543daed6e","modified":1537973434864},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"f559c68a25065a14f47da954a7617d87263e409d","modified":1537973434869},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1537973434873},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"a0c9e32549a8b8cf327ab9227b037f323cdb60ee","modified":1537973434868},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"bd40da3fba8735df5850956814e312bd7b3193d7","modified":1537973434867},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1537973434873},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1537973434873},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1537973434873},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1537973434874},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1537973434874},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1537973434876},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1537973434875},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1537973434875},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1537973434877},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1537973434877},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1537973434879},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1537973434879},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1537973434900},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1537973434901},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1537973434879},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"e345397e0585c9fed1449e614ec13e0224acf2ab","modified":1537973434868},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1537973434889},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1537973434889},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1537973434903},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"0686ba9cec3724b947e1cf00d68d9715e7b59616","modified":1537973434807},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"7905a7f625702b45645d8be1268cb8af3f698c70","modified":1537973434839},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1537973434839},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1537973434839},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"8a2421cb9005352905fae9d41a847ae56957247e","modified":1537973434839},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1537973434839},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1537973434840},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1537973434840},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"25dc25f61a232f03ca72472b7852f882448ec185","modified":1537973434840},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1537973434840},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"f5aa2ba3bfffc15475e7e72a55b5c9d18609fdf5","modified":1537973434840},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1537973434840},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1537973434841},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1537973434841},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1537973434841},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1537973434841},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"f54367c0feda6986c030cc4d15a0ca6ceea14bcb","modified":1537973434841},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"0f7f522cc6bfb3401d5afd62b0fcdf48bb2d604b","modified":1537973434841},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1537973434842},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"535b3b4f8cb1eec2558e094320e7dfb01f94c0e7","modified":1537973434842},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1537973434842},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"aea21141015ca8c409d8b33e3e34ec505f464e93","modified":1537973434842},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"a5d8617a24d7cb6c5ad91ea621183ca2c0917331","modified":1537973434842},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"36332c8a91f089f545f3c3e8ea90d08aa4d6e60c","modified":1537973434842},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1537973434842},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1537973434843},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"d5a4e4fc17f1f7e7c3a61b52d8e2e9677e139de7","modified":1537973434843},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1537973434843},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"e4055a0d2cd2b0ad9dc55928e2f3e7bd4e499da3","modified":1537973434843},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"7714f0af4432e04ad7cafc0a8c2dcdb72cbaa8ff","modified":1538056283133},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"0a6c0efffdf18bddbc1d1238feaed282b09cd0fe","modified":1537973434844},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1537973434844},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"89dd4f8b1f1cce3ad46cf2256038472712387d02","modified":1537973434844},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"efa5e5022e205b52786ce495d4879f5e7b8f84b2","modified":1537973434844},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1537973434844},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1537973434845},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"12937cae17c96c74d5c58db6cb29de3b2dfa14a2","modified":1537973434845},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"f7784aba0c1cd20d824c918c120012d57a5eaa2a","modified":1537973434845},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"50305b6ad7d09d2ffa4854e39f41ec1f4fe984fd","modified":1537973434845},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1537973434845},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1537973434846},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"1b3cc9f4e5a7f6e05b4100e9990b37b20d4a2005","modified":1537973434846},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"37e951e734a252fe8a81f452b963df2ba90bfe90","modified":1537973434846},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1537973434846},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1537973434847},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"ee7528900578ef4753effe05b346381c40de5499","modified":1537973434847},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"32c9156bea5bac9e9ad0b4c08ffbca8b3d9aac4b","modified":1537973434847},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"4ab5deed8c3b0c338212380f678f8382672e1bcb","modified":1537973434847},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"ead0d0f2321dc71505788c7f689f92257cf14947","modified":1537973434848},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"fd42777b9125fd8969dc39d4f15473e2b91b4142","modified":1537973434848},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1537973434848},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"d4e6d8d7b34dc69994593c208f875ae8f7e8a3ae","modified":1537973434848},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1537973434849},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"34935b40237c074be5f5e8818c14ccfd802b7439","modified":1537973434849},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"cce6772e2cdb4db85d35486ae4c6c59367fbdd40","modified":1537973434849},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1537973434849},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1537973434849},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1537973434849},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1ccfbd4d0f5754b2dc2719a91245c95f547a7652","modified":1537973434850},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1537973434855},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1537973434855},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1537973434856},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1537973434866},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1537973434866},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1537973434867},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1537973434867},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1537973434866},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1537973434874},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1537973434874},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1537973434874},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1537973434874},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1537973434875},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1537973434875},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1537973434881},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1537973434888},{"_id":"themes/next/.git/objects/pack/pack-09df78575dd506cafcb2c517908ed591431fdc71.idx","hash":"be430c584ec6e1499b87f9e416e72d0fbc2e3a26","modified":1537973434795},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1537973434883},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1537973434871},{"_id":"themes/next/source/lib/three/three.min.js","hash":"73f4cdc17e51a72b9bf5b9291f65386d615c483b","modified":1537973434899},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"98a8aa5cf7d62c2eff5f07ede8d844b874ef06ed","modified":1537973434886},{"_id":"themes/next/.git/objects/pack/pack-09df78575dd506cafcb2c517908ed591431fdc71.pack","hash":"eee901eb2f4a4df31eaa41634f4e9de643c3fb4e","modified":1537973434791}],"Category":[{"name":"你不知道的JavaScript","_id":"cjuowpbrb0004ja6jc2a10zah"},{"name":"TypeScript","_id":"cjuowpbrh0009ja6jk9r1ra4i"},{"name":"Node.js","_id":"cjuowpbrp000gja6jdxddminm"},{"name":"JavaScript","_id":"cjuowpbrx000wja6jegoh5jmz"},{"name":"vue","_id":"cjuowpbs40014ja6jplwzm5ur"},{"name":"随笔","_id":"cjuowpbs7001dja6jl8wsukr5"},{"name":"H5","_id":"cjuowpbsc001tja6jmzfg4y7u"},{"name":"React","_id":"cjuowpbsf0020ja6ja8mwc4l0"},{"name":"小程序","_id":"cjuowpbsg0028ja6jkwsduk8r"}],"Data":[],"Page":[{"title":"categories","date":"2018-09-26T15:28:20.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-09-26 23:28:20\ntype: \"categories\"\n---\n","updated":"2018-09-26T15:28:41.177Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjuowpbr40000ja6jdixthbzn","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"0201-11-15T11:04:22.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 201-11-15 19:10:05\ntype: \"tags\"\n---\n","updated":"2018-09-26T15:42:57.594Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjuowpbr90002ja6jf5m0pi20","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"作用域","date":"2019-03-30T15:37:33.000Z","_content":"### 作用域\n<!-- more -->\n\n### 作用域是什么\n> 作用域就是一套规则，用于确定在何处以及如何查找变量（标识符）。\nLHS查询：查找的目的是对变量进行赋值。\nRHS查询：目的是获取变量的值。\n嵌套作用域：引擎从当前执行作用域开始查找变量，如果没找到，就向上一级继续查找。\n当抵达最外层的全局作用域时，无论有没有找到，查找过程都会停止\n#### JS编译原理\n例如：var a = 2;\n> 任何JavaScript代码片段在执行前都要进行编译（通常就在执行前）。因此，JavaScript编译器。首先会对var a = 2;这段程序进行编译,然后做好执行它的准备，并且马上就会执行它。\n\n\n一. JS编译\n· 引擎\n从头到尾负责整个JavaScript程序的编译及执行过程。\n· 编译器\n引擎的好朋友之一，负责语法分析及代码生成等脏活累活\n· 作用域\n引擎的另一位好朋友，负责收集并维护所有声明的标识符（变量）组成的\n一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。\n\n二.接下来 var a = 2的编译过程\n1.编译器询问作用域是否已经有有一个该名称的变量存在作用域集合中。如果是，编译器就会忽略该声明，继续进行编译。否则在该作用域的集合重声明一个新的变量，命名为a。\n\n2.编译器为引擎生成运行所需的代码，用来处理a = 2的操作。首先询问作用域，当前有没有a的变量，有，引擎使用a的变量。没有则引擎继续查找该变量。如果最终找到a变量，把2赋值给a。没找到抛出异常!\n\n### 词法作用域\n> 词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况时这样的）。\n\n```\nfunction foo(a) {\n    var b = a * 2;\n\n    function bar(c) {\n        console.log(a,b,c)\n    }\n    bar(b*3)\n}\nfoo(2) //2,4,12\n```\n![image](/images/cifazuoyongyu.png)\n1.整个全局作用句,有一个标识符：foo。\n2.foo所创建的作用域，有三个标识符：a,bar和b。\n3.bar所创建的作用域，有一个标识符：c。\n\n无论函数在哪里被调用，它的词法作用域都只由函数被声明时所处都位置决定。词法作用域查找只会查找一级标识符，比如a,b,c。如果代码中引用来foo,bar,baz，词法作用域只会试图查找foo标识符,找到这个变量后，对象属性访问规则分别接管bar和baz属性都访问。\n\n### 函数作用域\n#### 函数作用域\n> 函数作用域：属于这个函数的全部变量都可以在整个函数都范围内使用及复用（事实上在嵌套都作用域也可以使用）。这种数据方案非常有用，能充分利用JavaScript变量可以根据需要改变值类型都“动态”特效。\n\n例如：\n```\nfunction doSomething(a) {\n    b = a + doSomethingElse(a*2)\n    console.log(b*3)\n}\nfunction doSomethingElse(a) {\n    return a - 1;\n}\nvar b;\ndoSomething(2) //15\n```\nb和doSomethingElse应该是doSomething内部具体实现的“私有”内容。给予外部作用域对b和doSomethingElse对“访问权限”。导致他们可能被有意无意以非预期对方式使用。\n\n```\nfunction doSomething(a) {\n    function doSomethingElse(a) {\n        return a - 1;\n    }\n    var b ;\n    b = a + doSomethingElse(a*2)\n    console.log(b*3)\n}\ndoSomething(2) //15\n```\nb和doSomethingElse都无法从外部被访问，只能被doSomething控制，设计上将具体内容私有化。\n#### 函数声明和函数表达式\n> 函数声明：如果function是声明中都第一个词，就是一个函数声明，否则是一个函数表达式。\n> 函数表达式：以(function...而不仅是以function...开始。)\n1.例如\n```\nvar a = 2;\nfunction foo() {\n    var a = 3;\n    console.log(a); //3\n}\nfoo()\nconsole.log(a); //2\n```\n具名函数foo()本身污染所在都作用域，并且必须显式通过foo()调用才能运行其中代码。如果函数不需要函数名自动运行？\n\n```\nvar a = 2;\n(functgion foo() {\n    var a = 3;\n    console.log(a); //3\n})();\nconsole.log(a); //2\n```\n此foo函数被绑定在函数表达式自身都函数中而不是所在作用域中。意味foo只能在(function foo(){...})...被访问，外部作用域不行。foo被因此在自身意味不会非不要地污染外部作用域\n\n2.匿名和具名\n```\nsetTimeout(function() {\n\n},1000)\n```\n匿名函数表达式：没有名称和标识符。函数表达式可以是匿名的，而函数声明则不可以省略函数名。\n\n\n\n\n\n\n","source":"_posts/1-JS-zuoyongyu.md","raw":"---\ntitle: 作用域\ndate: 2019-03-30 23:37:33\ntags: ['你不知道的JavaScript']\ncategories: 你不知道的JavaScript\n---\n### 作用域\n<!-- more -->\n\n### 作用域是什么\n> 作用域就是一套规则，用于确定在何处以及如何查找变量（标识符）。\nLHS查询：查找的目的是对变量进行赋值。\nRHS查询：目的是获取变量的值。\n嵌套作用域：引擎从当前执行作用域开始查找变量，如果没找到，就向上一级继续查找。\n当抵达最外层的全局作用域时，无论有没有找到，查找过程都会停止\n#### JS编译原理\n例如：var a = 2;\n> 任何JavaScript代码片段在执行前都要进行编译（通常就在执行前）。因此，JavaScript编译器。首先会对var a = 2;这段程序进行编译,然后做好执行它的准备，并且马上就会执行它。\n\n\n一. JS编译\n· 引擎\n从头到尾负责整个JavaScript程序的编译及执行过程。\n· 编译器\n引擎的好朋友之一，负责语法分析及代码生成等脏活累活\n· 作用域\n引擎的另一位好朋友，负责收集并维护所有声明的标识符（变量）组成的\n一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。\n\n二.接下来 var a = 2的编译过程\n1.编译器询问作用域是否已经有有一个该名称的变量存在作用域集合中。如果是，编译器就会忽略该声明，继续进行编译。否则在该作用域的集合重声明一个新的变量，命名为a。\n\n2.编译器为引擎生成运行所需的代码，用来处理a = 2的操作。首先询问作用域，当前有没有a的变量，有，引擎使用a的变量。没有则引擎继续查找该变量。如果最终找到a变量，把2赋值给a。没找到抛出异常!\n\n### 词法作用域\n> 词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况时这样的）。\n\n```\nfunction foo(a) {\n    var b = a * 2;\n\n    function bar(c) {\n        console.log(a,b,c)\n    }\n    bar(b*3)\n}\nfoo(2) //2,4,12\n```\n![image](/images/cifazuoyongyu.png)\n1.整个全局作用句,有一个标识符：foo。\n2.foo所创建的作用域，有三个标识符：a,bar和b。\n3.bar所创建的作用域，有一个标识符：c。\n\n无论函数在哪里被调用，它的词法作用域都只由函数被声明时所处都位置决定。词法作用域查找只会查找一级标识符，比如a,b,c。如果代码中引用来foo,bar,baz，词法作用域只会试图查找foo标识符,找到这个变量后，对象属性访问规则分别接管bar和baz属性都访问。\n\n### 函数作用域\n#### 函数作用域\n> 函数作用域：属于这个函数的全部变量都可以在整个函数都范围内使用及复用（事实上在嵌套都作用域也可以使用）。这种数据方案非常有用，能充分利用JavaScript变量可以根据需要改变值类型都“动态”特效。\n\n例如：\n```\nfunction doSomething(a) {\n    b = a + doSomethingElse(a*2)\n    console.log(b*3)\n}\nfunction doSomethingElse(a) {\n    return a - 1;\n}\nvar b;\ndoSomething(2) //15\n```\nb和doSomethingElse应该是doSomething内部具体实现的“私有”内容。给予外部作用域对b和doSomethingElse对“访问权限”。导致他们可能被有意无意以非预期对方式使用。\n\n```\nfunction doSomething(a) {\n    function doSomethingElse(a) {\n        return a - 1;\n    }\n    var b ;\n    b = a + doSomethingElse(a*2)\n    console.log(b*3)\n}\ndoSomething(2) //15\n```\nb和doSomethingElse都无法从外部被访问，只能被doSomething控制，设计上将具体内容私有化。\n#### 函数声明和函数表达式\n> 函数声明：如果function是声明中都第一个词，就是一个函数声明，否则是一个函数表达式。\n> 函数表达式：以(function...而不仅是以function...开始。)\n1.例如\n```\nvar a = 2;\nfunction foo() {\n    var a = 3;\n    console.log(a); //3\n}\nfoo()\nconsole.log(a); //2\n```\n具名函数foo()本身污染所在都作用域，并且必须显式通过foo()调用才能运行其中代码。如果函数不需要函数名自动运行？\n\n```\nvar a = 2;\n(functgion foo() {\n    var a = 3;\n    console.log(a); //3\n})();\nconsole.log(a); //2\n```\n此foo函数被绑定在函数表达式自身都函数中而不是所在作用域中。意味foo只能在(function foo(){...})...被访问，外部作用域不行。foo被因此在自身意味不会非不要地污染外部作用域\n\n2.匿名和具名\n```\nsetTimeout(function() {\n\n},1000)\n```\n匿名函数表达式：没有名称和标识符。函数表达式可以是匿名的，而函数声明则不可以省略函数名。\n\n\n\n\n\n\n","slug":"1-JS-zuoyongyu","published":1,"updated":"2019-03-31T14:23:45.208Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuowpbr50001ja6j6fy7yz6h","content":"<h3 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h3><a id=\"more\"></a>\n<h3 id=\"作用域是什么\"><a href=\"#作用域是什么\" class=\"headerlink\" title=\"作用域是什么\"></a>作用域是什么</h3><blockquote>\n<p>作用域就是一套规则，用于确定在何处以及如何查找变量（标识符）。<br>LHS查询：查找的目的是对变量进行赋值。<br>RHS查询：目的是获取变量的值。<br>嵌套作用域：引擎从当前执行作用域开始查找变量，如果没找到，就向上一级继续查找。<br>当抵达最外层的全局作用域时，无论有没有找到，查找过程都会停止</p>\n</blockquote>\n<h4 id=\"JS编译原理\"><a href=\"#JS编译原理\" class=\"headerlink\" title=\"JS编译原理\"></a>JS编译原理</h4><p>例如：var a = 2;</p>\n<blockquote>\n<p>任何JavaScript代码片段在执行前都要进行编译（通常就在执行前）。因此，JavaScript编译器。首先会对var a = 2;这段程序进行编译,然后做好执行它的准备，并且马上就会执行它。</p>\n</blockquote>\n<p>一. JS编译<br>· 引擎<br>从头到尾负责整个JavaScript程序的编译及执行过程。<br>· 编译器<br>引擎的好朋友之一，负责语法分析及代码生成等脏活累活<br>· 作用域<br>引擎的另一位好朋友，负责收集并维护所有声明的标识符（变量）组成的<br>一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。</p>\n<p>二.接下来 var a = 2的编译过程<br>1.编译器询问作用域是否已经有有一个该名称的变量存在作用域集合中。如果是，编译器就会忽略该声明，继续进行编译。否则在该作用域的集合重声明一个新的变量，命名为a。</p>\n<p>2.编译器为引擎生成运行所需的代码，用来处理a = 2的操作。首先询问作用域，当前有没有a的变量，有，引擎使用a的变量。没有则引擎继续查找该变量。如果最终找到a变量，把2赋值给a。没找到抛出异常!</p>\n<h3 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h3><blockquote>\n<p>词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况时这样的）。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo(a) &#123;</span><br><span class=\"line\">    var b = a * 2;</span><br><span class=\"line\"></span><br><span class=\"line\">    function bar(c) &#123;</span><br><span class=\"line\">        console.log(a,b,c)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    bar(b*3)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo(2) //2,4,12</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/cifazuoyongyu.png\" alt=\"image\"><br>1.整个全局作用句,有一个标识符：foo。<br>2.foo所创建的作用域，有三个标识符：a,bar和b。<br>3.bar所创建的作用域，有一个标识符：c。</p>\n<p>无论函数在哪里被调用，它的词法作用域都只由函数被声明时所处都位置决定。词法作用域查找只会查找一级标识符，比如a,b,c。如果代码中引用来foo,bar,baz，词法作用域只会试图查找foo标识符,找到这个变量后，对象属性访问规则分别接管bar和baz属性都访问。</p>\n<h3 id=\"函数作用域\"><a href=\"#函数作用域\" class=\"headerlink\" title=\"函数作用域\"></a>函数作用域</h3><h4 id=\"函数作用域-1\"><a href=\"#函数作用域-1\" class=\"headerlink\" title=\"函数作用域\"></a>函数作用域</h4><blockquote>\n<p>函数作用域：属于这个函数的全部变量都可以在整个函数都范围内使用及复用（事实上在嵌套都作用域也可以使用）。这种数据方案非常有用，能充分利用JavaScript变量可以根据需要改变值类型都“动态”特效。</p>\n</blockquote>\n<p>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function doSomething(a) &#123;</span><br><span class=\"line\">    b = a + doSomethingElse(a*2)</span><br><span class=\"line\">    console.log(b*3)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function doSomethingElse(a) &#123;</span><br><span class=\"line\">    return a - 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var b;</span><br><span class=\"line\">doSomething(2) //15</span><br></pre></td></tr></table></figure></p>\n<p>b和doSomethingElse应该是doSomething内部具体实现的“私有”内容。给予外部作用域对b和doSomethingElse对“访问权限”。导致他们可能被有意无意以非预期对方式使用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function doSomething(a) &#123;</span><br><span class=\"line\">    function doSomethingElse(a) &#123;</span><br><span class=\"line\">        return a - 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var b ;</span><br><span class=\"line\">    b = a + doSomethingElse(a*2)</span><br><span class=\"line\">    console.log(b*3)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">doSomething(2) //15</span><br></pre></td></tr></table></figure>\n<p>b和doSomethingElse都无法从外部被访问，只能被doSomething控制，设计上将具体内容私有化。</p>\n<h4 id=\"函数声明和函数表达式\"><a href=\"#函数声明和函数表达式\" class=\"headerlink\" title=\"函数声明和函数表达式\"></a>函数声明和函数表达式</h4><blockquote>\n<p>函数声明：如果function是声明中都第一个词，就是一个函数声明，否则是一个函数表达式。<br>函数表达式：以(function…而不仅是以function…开始。)<br>1.例如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 2;</span><br><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">    var a = 3;</span><br><span class=\"line\">    console.log(a); //3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo()</span><br><span class=\"line\">console.log(a); //2</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>具名函数foo()本身污染所在都作用域，并且必须显式通过foo()调用才能运行其中代码。如果函数不需要函数名自动运行？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 2;</span><br><span class=\"line\">(functgion foo() &#123;</span><br><span class=\"line\">    var a = 3;</span><br><span class=\"line\">    console.log(a); //3</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\">console.log(a); //2</span><br></pre></td></tr></table></figure>\n<p>此foo函数被绑定在函数表达式自身都函数中而不是所在作用域中。意味foo只能在(function foo(){…})…被访问，外部作用域不行。foo被因此在自身意味不会非不要地污染外部作用域</p>\n<p>2.匿名和具名<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(function() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;,1000)</span><br></pre></td></tr></table></figure></p>\n<p>匿名函数表达式：没有名称和标识符。函数表达式可以是匿名的，而函数声明则不可以省略函数名。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h3>","more":"<h3 id=\"作用域是什么\"><a href=\"#作用域是什么\" class=\"headerlink\" title=\"作用域是什么\"></a>作用域是什么</h3><blockquote>\n<p>作用域就是一套规则，用于确定在何处以及如何查找变量（标识符）。<br>LHS查询：查找的目的是对变量进行赋值。<br>RHS查询：目的是获取变量的值。<br>嵌套作用域：引擎从当前执行作用域开始查找变量，如果没找到，就向上一级继续查找。<br>当抵达最外层的全局作用域时，无论有没有找到，查找过程都会停止</p>\n</blockquote>\n<h4 id=\"JS编译原理\"><a href=\"#JS编译原理\" class=\"headerlink\" title=\"JS编译原理\"></a>JS编译原理</h4><p>例如：var a = 2;</p>\n<blockquote>\n<p>任何JavaScript代码片段在执行前都要进行编译（通常就在执行前）。因此，JavaScript编译器。首先会对var a = 2;这段程序进行编译,然后做好执行它的准备，并且马上就会执行它。</p>\n</blockquote>\n<p>一. JS编译<br>· 引擎<br>从头到尾负责整个JavaScript程序的编译及执行过程。<br>· 编译器<br>引擎的好朋友之一，负责语法分析及代码生成等脏活累活<br>· 作用域<br>引擎的另一位好朋友，负责收集并维护所有声明的标识符（变量）组成的<br>一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。</p>\n<p>二.接下来 var a = 2的编译过程<br>1.编译器询问作用域是否已经有有一个该名称的变量存在作用域集合中。如果是，编译器就会忽略该声明，继续进行编译。否则在该作用域的集合重声明一个新的变量，命名为a。</p>\n<p>2.编译器为引擎生成运行所需的代码，用来处理a = 2的操作。首先询问作用域，当前有没有a的变量，有，引擎使用a的变量。没有则引擎继续查找该变量。如果最终找到a变量，把2赋值给a。没找到抛出异常!</p>\n<h3 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h3><blockquote>\n<p>词法作用域就是定义在词法阶段的作用域。换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况时这样的）。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo(a) &#123;</span><br><span class=\"line\">    var b = a * 2;</span><br><span class=\"line\"></span><br><span class=\"line\">    function bar(c) &#123;</span><br><span class=\"line\">        console.log(a,b,c)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    bar(b*3)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo(2) //2,4,12</span><br></pre></td></tr></table></figure>\n<p><img src=\"/images/cifazuoyongyu.png\" alt=\"image\"><br>1.整个全局作用句,有一个标识符：foo。<br>2.foo所创建的作用域，有三个标识符：a,bar和b。<br>3.bar所创建的作用域，有一个标识符：c。</p>\n<p>无论函数在哪里被调用，它的词法作用域都只由函数被声明时所处都位置决定。词法作用域查找只会查找一级标识符，比如a,b,c。如果代码中引用来foo,bar,baz，词法作用域只会试图查找foo标识符,找到这个变量后，对象属性访问规则分别接管bar和baz属性都访问。</p>\n<h3 id=\"函数作用域\"><a href=\"#函数作用域\" class=\"headerlink\" title=\"函数作用域\"></a>函数作用域</h3><h4 id=\"函数作用域-1\"><a href=\"#函数作用域-1\" class=\"headerlink\" title=\"函数作用域\"></a>函数作用域</h4><blockquote>\n<p>函数作用域：属于这个函数的全部变量都可以在整个函数都范围内使用及复用（事实上在嵌套都作用域也可以使用）。这种数据方案非常有用，能充分利用JavaScript变量可以根据需要改变值类型都“动态”特效。</p>\n</blockquote>\n<p>例如：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function doSomething(a) &#123;</span><br><span class=\"line\">    b = a + doSomethingElse(a*2)</span><br><span class=\"line\">    console.log(b*3)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function doSomethingElse(a) &#123;</span><br><span class=\"line\">    return a - 1;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var b;</span><br><span class=\"line\">doSomething(2) //15</span><br></pre></td></tr></table></figure></p>\n<p>b和doSomethingElse应该是doSomething内部具体实现的“私有”内容。给予外部作用域对b和doSomethingElse对“访问权限”。导致他们可能被有意无意以非预期对方式使用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function doSomething(a) &#123;</span><br><span class=\"line\">    function doSomethingElse(a) &#123;</span><br><span class=\"line\">        return a - 1;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    var b ;</span><br><span class=\"line\">    b = a + doSomethingElse(a*2)</span><br><span class=\"line\">    console.log(b*3)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">doSomething(2) //15</span><br></pre></td></tr></table></figure>\n<p>b和doSomethingElse都无法从外部被访问，只能被doSomething控制，设计上将具体内容私有化。</p>\n<h4 id=\"函数声明和函数表达式\"><a href=\"#函数声明和函数表达式\" class=\"headerlink\" title=\"函数声明和函数表达式\"></a>函数声明和函数表达式</h4><blockquote>\n<p>函数声明：如果function是声明中都第一个词，就是一个函数声明，否则是一个函数表达式。<br>函数表达式：以(function…而不仅是以function…开始。)<br>1.例如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 2;</span><br><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">    var a = 3;</span><br><span class=\"line\">    console.log(a); //3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo()</span><br><span class=\"line\">console.log(a); //2</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>具名函数foo()本身污染所在都作用域，并且必须显式通过foo()调用才能运行其中代码。如果函数不需要函数名自动运行？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = 2;</span><br><span class=\"line\">(functgion foo() &#123;</span><br><span class=\"line\">    var a = 3;</span><br><span class=\"line\">    console.log(a); //3</span><br><span class=\"line\">&#125;)();</span><br><span class=\"line\">console.log(a); //2</span><br></pre></td></tr></table></figure>\n<p>此foo函数被绑定在函数表达式自身都函数中而不是所在作用域中。意味foo只能在(function foo(){…})…被访问，外部作用域不行。foo被因此在自身意味不会非不要地污染外部作用域</p>\n<p>2.匿名和具名<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setTimeout(function() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;,1000)</span><br></pre></td></tr></table></figure></p>\n<p>匿名函数表达式：没有名称和标识符。函数表达式可以是匿名的，而函数声明则不可以省略函数名。</p>"},{"title":"TypeScript","date":"2019-03-09T00:47:56.000Z","_content":"### TypeScript\n<!-- more -->\n\n### TypeScipt介绍\n> TypeScript 是 JavaScript 的类型的超集，它可以编译成纯 JavaScript。编译出来的 JavaScript 可以运行在任何浏览器上。TypeScript 编译工具可以运行在任何服务器和任何系统上。TypeScript 是开源的。\n\nTypeScript 是 JavaScript 的一个超集，主要提供了类型系统和对 ES6 的支持，它由 微软 开发。\n\n### TS 好处\n1.代码的可维护性。类型系统实际上是最好的文档。\n2.非常包容，TS是JS的超集。\n3.活跃的社区。\n\n### Hello TypeScript\n```\nfunction sayHello(person:string) {\n    return 'Hello,' + person;\n}\nlet user = 'Tom';\n```\n编译成.js文件\n```\nfunction sayHello(person) {\n    return 'Hello, ' + person;\n}\nvar user = 'Tom';\nconsole.log(sayHello(user));\n```\n使用 : 指定变量的类型，: 的前后有没有空格都可以。\n","source":"_posts/1-ts.md","raw":"---\ntitle: TypeScript\ndate: 2019-03-09 08:47:56\ntags: ['TypeScript']\ncategories: TypeScript\n---\n### TypeScript\n<!-- more -->\n\n### TypeScipt介绍\n> TypeScript 是 JavaScript 的类型的超集，它可以编译成纯 JavaScript。编译出来的 JavaScript 可以运行在任何浏览器上。TypeScript 编译工具可以运行在任何服务器和任何系统上。TypeScript 是开源的。\n\nTypeScript 是 JavaScript 的一个超集，主要提供了类型系统和对 ES6 的支持，它由 微软 开发。\n\n### TS 好处\n1.代码的可维护性。类型系统实际上是最好的文档。\n2.非常包容，TS是JS的超集。\n3.活跃的社区。\n\n### Hello TypeScript\n```\nfunction sayHello(person:string) {\n    return 'Hello,' + person;\n}\nlet user = 'Tom';\n```\n编译成.js文件\n```\nfunction sayHello(person) {\n    return 'Hello, ' + person;\n}\nvar user = 'Tom';\nconsole.log(sayHello(user));\n```\n使用 : 指定变量的类型，: 的前后有没有空格都可以。\n","slug":"1-ts","published":1,"updated":"2019-03-09T00:54:36.204Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuowpbra0003ja6jxwls6gvt","content":"<h3 id=\"TypeScript\"><a href=\"#TypeScript\" class=\"headerlink\" title=\"TypeScript\"></a>TypeScript</h3><a id=\"more\"></a>\n<h3 id=\"TypeScipt介绍\"><a href=\"#TypeScipt介绍\" class=\"headerlink\" title=\"TypeScipt介绍\"></a>TypeScipt介绍</h3><blockquote>\n<p>TypeScript 是 JavaScript 的类型的超集，它可以编译成纯 JavaScript。编译出来的 JavaScript 可以运行在任何浏览器上。TypeScript 编译工具可以运行在任何服务器和任何系统上。TypeScript 是开源的。</p>\n</blockquote>\n<p>TypeScript 是 JavaScript 的一个超集，主要提供了类型系统和对 ES6 的支持，它由 微软 开发。</p>\n<h3 id=\"TS-好处\"><a href=\"#TS-好处\" class=\"headerlink\" title=\"TS 好处\"></a>TS 好处</h3><p>1.代码的可维护性。类型系统实际上是最好的文档。<br>2.非常包容，TS是JS的超集。<br>3.活跃的社区。</p>\n<h3 id=\"Hello-TypeScript\"><a href=\"#Hello-TypeScript\" class=\"headerlink\" title=\"Hello TypeScript\"></a>Hello TypeScript</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function sayHello(person:string) &#123;</span><br><span class=\"line\">    return &apos;Hello,&apos; + person;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let user = &apos;Tom&apos;;</span><br></pre></td></tr></table></figure>\n<p>编译成.js文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function sayHello(person) &#123;</span><br><span class=\"line\">    return &apos;Hello, &apos; + person;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var user = &apos;Tom&apos;;</span><br><span class=\"line\">console.log(sayHello(user));</span><br></pre></td></tr></table></figure></p>\n<p>使用 : 指定变量的类型，: 的前后有没有空格都可以。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"TypeScript\"><a href=\"#TypeScript\" class=\"headerlink\" title=\"TypeScript\"></a>TypeScript</h3>","more":"<h3 id=\"TypeScipt介绍\"><a href=\"#TypeScipt介绍\" class=\"headerlink\" title=\"TypeScipt介绍\"></a>TypeScipt介绍</h3><blockquote>\n<p>TypeScript 是 JavaScript 的类型的超集，它可以编译成纯 JavaScript。编译出来的 JavaScript 可以运行在任何浏览器上。TypeScript 编译工具可以运行在任何服务器和任何系统上。TypeScript 是开源的。</p>\n</blockquote>\n<p>TypeScript 是 JavaScript 的一个超集，主要提供了类型系统和对 ES6 的支持，它由 微软 开发。</p>\n<h3 id=\"TS-好处\"><a href=\"#TS-好处\" class=\"headerlink\" title=\"TS 好处\"></a>TS 好处</h3><p>1.代码的可维护性。类型系统实际上是最好的文档。<br>2.非常包容，TS是JS的超集。<br>3.活跃的社区。</p>\n<h3 id=\"Hello-TypeScript\"><a href=\"#Hello-TypeScript\" class=\"headerlink\" title=\"Hello TypeScript\"></a>Hello TypeScript</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function sayHello(person:string) &#123;</span><br><span class=\"line\">    return &apos;Hello,&apos; + person;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let user = &apos;Tom&apos;;</span><br></pre></td></tr></table></figure>\n<p>编译成.js文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function sayHello(person) &#123;</span><br><span class=\"line\">    return &apos;Hello, &apos; + person;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var user = &apos;Tom&apos;;</span><br><span class=\"line\">console.log(sayHello(user));</span><br></pre></td></tr></table></figure></p>\n<p>使用 : 指定变量的类型，: 的前后有没有空格都可以。</p>"},{"title":"Node.js介绍","date":"2019-01-13T11:04:56.000Z","_content":"### Node.js概述\n<!-- more -->\n\n### Node.js概述\n> Node.js的首要目标是提供一种简单的、用于创建高性能服务器及可在该服务器中运行的各种应用程序的开发工具。\n\n#### 实现高性能的服务器\n1. Node.js运行的是高性能 V8 JavaScript脚本语言，该语言是一种可以运行在服务端的JavaScript脚本语言。V8 JavaScript 引擎是由Google公司使用C++语言开发的一种高性能JavaScript引擎。不止在浏览器中运行，Node.js将其转用在了服务器中，提供了各种不同用途的API。\n2.  意味开发者编写的高端JavaScript脚本代码与开发者编写的低端的C语言具有非常相近的执行效率。\n\n#### 非阻塞型I/O及事件环机制\n1. 非阻塞型I/O\n例如在传统的单线程处理机制中，执行了访问数据库的代码之后，整个线程都将暂停下来，等待数据库返回的查询结果之后才能继续执行其后面的代码，I/O操作阻塞了代码的执行，降低了程序的执行效率。而Node.js采用非阻塞型I/O机制，执行了访问数据库的代码之后将立即执行后面的代码，把数据库返回结果的处理代码放在回调函数中执行，从而提高程序的执行效率。\n\n2. 事件环机制\n在Node.js中，在一个时刻只能执行一个事件回调函数，但是在执行一个事件回调函数的中途可以转而处理其他事件（包括触发新的事件，声明该事件的回调函数等），然后返回继续执行原事件回调函数，这种处理机制称为事件环机制。\n\n### Node.js适合开发的应用程序\n> 当应用程序需要处理大量并发的输入/输出，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候。\n\n1. 聊天服务器:存在大量用户与聊天服务器之间的并发连接，而服务器本身并不存在非常复杂的处理。\n2. 综合服务类网站或电子商务网站的服务器。\n\n### 示例应用程序\n```\n// 引入http模块\nconst http = require('http');\n// createServer方法创建用于接受HTTP客户端请求并响应的HTTP服务器应用程序\nhttp.createServer(function(req,res) {\n/**\n *  req:客户端请求对象，res:服务端所做出的响应对象。\n *  响应状态码定义200，内容类型text/html。\n *  定义utf-8为了在浏览器中显示中文\n *  通过响应对象的end方法输出一行HTMl代码并结束响应流\n */\n    res.writeHead(200,('Content-Type':'text-html'));\n    res.write('<head><meta charset=\"utf-8\"/></head>')\n    res.end('hello word')\n}).listen(8081);\n\n```\n","source":"_posts/1-Node-introduction.md","raw":"---\ntitle: Node.js介绍\ndate: 2019-01-13 19:04:56\ntags: ['Node.js']\ncategories: Node.js\n---\n### Node.js概述\n<!-- more -->\n\n### Node.js概述\n> Node.js的首要目标是提供一种简单的、用于创建高性能服务器及可在该服务器中运行的各种应用程序的开发工具。\n\n#### 实现高性能的服务器\n1. Node.js运行的是高性能 V8 JavaScript脚本语言，该语言是一种可以运行在服务端的JavaScript脚本语言。V8 JavaScript 引擎是由Google公司使用C++语言开发的一种高性能JavaScript引擎。不止在浏览器中运行，Node.js将其转用在了服务器中，提供了各种不同用途的API。\n2.  意味开发者编写的高端JavaScript脚本代码与开发者编写的低端的C语言具有非常相近的执行效率。\n\n#### 非阻塞型I/O及事件环机制\n1. 非阻塞型I/O\n例如在传统的单线程处理机制中，执行了访问数据库的代码之后，整个线程都将暂停下来，等待数据库返回的查询结果之后才能继续执行其后面的代码，I/O操作阻塞了代码的执行，降低了程序的执行效率。而Node.js采用非阻塞型I/O机制，执行了访问数据库的代码之后将立即执行后面的代码，把数据库返回结果的处理代码放在回调函数中执行，从而提高程序的执行效率。\n\n2. 事件环机制\n在Node.js中，在一个时刻只能执行一个事件回调函数，但是在执行一个事件回调函数的中途可以转而处理其他事件（包括触发新的事件，声明该事件的回调函数等），然后返回继续执行原事件回调函数，这种处理机制称为事件环机制。\n\n### Node.js适合开发的应用程序\n> 当应用程序需要处理大量并发的输入/输出，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候。\n\n1. 聊天服务器:存在大量用户与聊天服务器之间的并发连接，而服务器本身并不存在非常复杂的处理。\n2. 综合服务类网站或电子商务网站的服务器。\n\n### 示例应用程序\n```\n// 引入http模块\nconst http = require('http');\n// createServer方法创建用于接受HTTP客户端请求并响应的HTTP服务器应用程序\nhttp.createServer(function(req,res) {\n/**\n *  req:客户端请求对象，res:服务端所做出的响应对象。\n *  响应状态码定义200，内容类型text/html。\n *  定义utf-8为了在浏览器中显示中文\n *  通过响应对象的end方法输出一行HTMl代码并结束响应流\n */\n    res.writeHead(200,('Content-Type':'text-html'));\n    res.write('<head><meta charset=\"utf-8\"/></head>')\n    res.end('hello word')\n}).listen(8081);\n\n```\n","slug":"1-Node-introduction","published":1,"updated":"2019-01-13T12:14:33.765Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuowpbre0006ja6jvniwrhsw","content":"<h3 id=\"Node-js概述\"><a href=\"#Node-js概述\" class=\"headerlink\" title=\"Node.js概述\"></a>Node.js概述</h3><a id=\"more\"></a>\n<h3 id=\"Node-js概述-1\"><a href=\"#Node-js概述-1\" class=\"headerlink\" title=\"Node.js概述\"></a>Node.js概述</h3><blockquote>\n<p>Node.js的首要目标是提供一种简单的、用于创建高性能服务器及可在该服务器中运行的各种应用程序的开发工具。</p>\n</blockquote>\n<h4 id=\"实现高性能的服务器\"><a href=\"#实现高性能的服务器\" class=\"headerlink\" title=\"实现高性能的服务器\"></a>实现高性能的服务器</h4><ol>\n<li>Node.js运行的是高性能 V8 JavaScript脚本语言，该语言是一种可以运行在服务端的JavaScript脚本语言。V8 JavaScript 引擎是由Google公司使用C++语言开发的一种高性能JavaScript引擎。不止在浏览器中运行，Node.js将其转用在了服务器中，提供了各种不同用途的API。</li>\n<li>意味开发者编写的高端JavaScript脚本代码与开发者编写的低端的C语言具有非常相近的执行效率。</li>\n</ol>\n<h4 id=\"非阻塞型I-O及事件环机制\"><a href=\"#非阻塞型I-O及事件环机制\" class=\"headerlink\" title=\"非阻塞型I/O及事件环机制\"></a>非阻塞型I/O及事件环机制</h4><ol>\n<li><p>非阻塞型I/O<br>例如在传统的单线程处理机制中，执行了访问数据库的代码之后，整个线程都将暂停下来，等待数据库返回的查询结果之后才能继续执行其后面的代码，I/O操作阻塞了代码的执行，降低了程序的执行效率。而Node.js采用非阻塞型I/O机制，执行了访问数据库的代码之后将立即执行后面的代码，把数据库返回结果的处理代码放在回调函数中执行，从而提高程序的执行效率。</p>\n</li>\n<li><p>事件环机制<br>在Node.js中，在一个时刻只能执行一个事件回调函数，但是在执行一个事件回调函数的中途可以转而处理其他事件（包括触发新的事件，声明该事件的回调函数等），然后返回继续执行原事件回调函数，这种处理机制称为事件环机制。</p>\n</li>\n</ol>\n<h3 id=\"Node-js适合开发的应用程序\"><a href=\"#Node-js适合开发的应用程序\" class=\"headerlink\" title=\"Node.js适合开发的应用程序\"></a>Node.js适合开发的应用程序</h3><blockquote>\n<p>当应用程序需要处理大量并发的输入/输出，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候。</p>\n</blockquote>\n<ol>\n<li>聊天服务器:存在大量用户与聊天服务器之间的并发连接，而服务器本身并不存在非常复杂的处理。</li>\n<li>综合服务类网站或电子商务网站的服务器。</li>\n</ol>\n<h3 id=\"示例应用程序\"><a href=\"#示例应用程序\" class=\"headerlink\" title=\"示例应用程序\"></a>示例应用程序</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 引入http模块</span><br><span class=\"line\">const http = require(&apos;http&apos;);</span><br><span class=\"line\">// createServer方法创建用于接受HTTP客户端请求并响应的HTTP服务器应用程序</span><br><span class=\"line\">http.createServer(function(req,res) &#123;</span><br><span class=\"line\">/**</span><br><span class=\"line\"> *  req:客户端请求对象，res:服务端所做出的响应对象。</span><br><span class=\"line\"> *  响应状态码定义200，内容类型text/html。</span><br><span class=\"line\"> *  定义utf-8为了在浏览器中显示中文</span><br><span class=\"line\"> *  通过响应对象的end方法输出一行HTMl代码并结束响应流</span><br><span class=\"line\"> */</span><br><span class=\"line\">    res.writeHead(200,(&apos;Content-Type&apos;:&apos;text-html&apos;));</span><br><span class=\"line\">    res.write(&apos;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;/head&gt;&apos;)</span><br><span class=\"line\">    res.end(&apos;hello word&apos;)</span><br><span class=\"line\">&#125;).listen(8081);</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"Node-js概述\"><a href=\"#Node-js概述\" class=\"headerlink\" title=\"Node.js概述\"></a>Node.js概述</h3>","more":"<h3 id=\"Node-js概述-1\"><a href=\"#Node-js概述-1\" class=\"headerlink\" title=\"Node.js概述\"></a>Node.js概述</h3><blockquote>\n<p>Node.js的首要目标是提供一种简单的、用于创建高性能服务器及可在该服务器中运行的各种应用程序的开发工具。</p>\n</blockquote>\n<h4 id=\"实现高性能的服务器\"><a href=\"#实现高性能的服务器\" class=\"headerlink\" title=\"实现高性能的服务器\"></a>实现高性能的服务器</h4><ol>\n<li>Node.js运行的是高性能 V8 JavaScript脚本语言，该语言是一种可以运行在服务端的JavaScript脚本语言。V8 JavaScript 引擎是由Google公司使用C++语言开发的一种高性能JavaScript引擎。不止在浏览器中运行，Node.js将其转用在了服务器中，提供了各种不同用途的API。</li>\n<li>意味开发者编写的高端JavaScript脚本代码与开发者编写的低端的C语言具有非常相近的执行效率。</li>\n</ol>\n<h4 id=\"非阻塞型I-O及事件环机制\"><a href=\"#非阻塞型I-O及事件环机制\" class=\"headerlink\" title=\"非阻塞型I/O及事件环机制\"></a>非阻塞型I/O及事件环机制</h4><ol>\n<li><p>非阻塞型I/O<br>例如在传统的单线程处理机制中，执行了访问数据库的代码之后，整个线程都将暂停下来，等待数据库返回的查询结果之后才能继续执行其后面的代码，I/O操作阻塞了代码的执行，降低了程序的执行效率。而Node.js采用非阻塞型I/O机制，执行了访问数据库的代码之后将立即执行后面的代码，把数据库返回结果的处理代码放在回调函数中执行，从而提高程序的执行效率。</p>\n</li>\n<li><p>事件环机制<br>在Node.js中，在一个时刻只能执行一个事件回调函数，但是在执行一个事件回调函数的中途可以转而处理其他事件（包括触发新的事件，声明该事件的回调函数等），然后返回继续执行原事件回调函数，这种处理机制称为事件环机制。</p>\n</li>\n</ol>\n<h3 id=\"Node-js适合开发的应用程序\"><a href=\"#Node-js适合开发的应用程序\" class=\"headerlink\" title=\"Node.js适合开发的应用程序\"></a>Node.js适合开发的应用程序</h3><blockquote>\n<p>当应用程序需要处理大量并发的输入/输出，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候。</p>\n</blockquote>\n<ol>\n<li>聊天服务器:存在大量用户与聊天服务器之间的并发连接，而服务器本身并不存在非常复杂的处理。</li>\n<li>综合服务类网站或电子商务网站的服务器。</li>\n</ol>\n<h3 id=\"示例应用程序\"><a href=\"#示例应用程序\" class=\"headerlink\" title=\"示例应用程序\"></a>示例应用程序</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 引入http模块</span><br><span class=\"line\">const http = require(&apos;http&apos;);</span><br><span class=\"line\">// createServer方法创建用于接受HTTP客户端请求并响应的HTTP服务器应用程序</span><br><span class=\"line\">http.createServer(function(req,res) &#123;</span><br><span class=\"line\">/**</span><br><span class=\"line\"> *  req:客户端请求对象，res:服务端所做出的响应对象。</span><br><span class=\"line\"> *  响应状态码定义200，内容类型text/html。</span><br><span class=\"line\"> *  定义utf-8为了在浏览器中显示中文</span><br><span class=\"line\"> *  通过响应对象的end方法输出一行HTMl代码并结束响应流</span><br><span class=\"line\"> */</span><br><span class=\"line\">    res.writeHead(200,(&apos;Content-Type&apos;:&apos;text-html&apos;));</span><br><span class=\"line\">    res.write(&apos;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;/head&gt;&apos;)</span><br><span class=\"line\">    res.end(&apos;hello word&apos;)</span><br><span class=\"line\">&#125;).listen(8081);</span><br></pre></td></tr></table></figure>"},{"title":"提升和作用域闭包","date":"2019-03-31T16:00:00.000Z","_content":"### 提升和作用域闭包\n<!-- more -->\n\n### 提升\n> 这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。\n可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的\n最顶端，这个过程被称为提升。\n> 声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。 \n要注意避免重复声明，特别是当普通的  var 声明和函数声明混合在一起的时候，否则会引 \n起很多危险的问题！\n\n```\na = 2;\nvar a;\nconsole.log(a) //2\n------------------\n进行如下处理\nvar a;\na = 2;\n变量出现的位置被“移动”到了最上面，这个过程就叫做提升\n```\n变量和函数在内的所有声明都会在任何代码被执行前首先被处理。JavaScript实际会将其看两个声明：var a;和a = 2;第一个定义声明是在编译阶段进行，第二个赋值声明会被留在原地等待执行阶段。\n\n```\nfoo()\nfunction foo() {\n    console.log(a) //undefined\n    var a = 2;\n}\n--------------\n进行如下处理\nfunction foo() {\n    var a;\n    console.log(a) //undefined\n    a = 2;\n}\nfoo()\n```\nfoo函数声明被提升了，但函数表达式却不会被提升。\n```\nfoo() //TypeError\nvar foo = function bar() {\n    //...\n}\n```\n即使是具名函数表达式，名称标识符在赋值之前也无法在所在作用域中使用。\n\n```\nfoo() //1\nvar foo;\nfunction foo() {\n    console.log(1)\n}\nfoo = function() {\n    console.log(2)\n}\n-----------\n进行如下处理\nfunction foo() {\n    console.log(1)\n}\nfoo() //1\nfoo = function() {\n    console.log(2)\n}\n```\n函数声明和变量都会被提升，函数首先被提升，然后才是变量。后面的函数声明还可以覆盖前面的函数声明\n\n```\nfoo() //3\n\nfunction foo() {\n    console.log(1)\n}\n\nvar foo = function() {\n    console.log(2)\n}\n\nfunction foo() {\n    console.log(3)\n}\n```\n\n### 作用域闭包\n> 闭包就是能够读取其他函数内部变量的函数。由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成\"定义在一个函数内部的函数\"。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。\n\n```\nfunction foo() {\n    var a = 2;\n    function bar() {\n        console.log(a)\n    }\n    return bar\n}\nvar baz = bar();\nbaz(); //2\n```\n函数baz()能够访问foo()的内部作用域。将bar()函数本身当作一个值类型进行传递。而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此 \n没有被回收。谁在使用这个内部作用域？原来是  bar() 本身在使用。bar()拥有foo()内部作用域的闭包，该作用域一直存活,bar()本身在使用。bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。\n\n","source":"_posts/2-JS-tishenghebibao.md","raw":"---\ntitle: 提升和作用域闭包\ndate: 2019-04-1 \ntags: ['你不知道的JavaScript']\ncategories: 你不知道的JavaScript\n---\n### 提升和作用域闭包\n<!-- more -->\n\n### 提升\n> 这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。\n可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的\n最顶端，这个过程被称为提升。\n> 声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。 \n要注意避免重复声明，特别是当普通的  var 声明和函数声明混合在一起的时候，否则会引 \n起很多危险的问题！\n\n```\na = 2;\nvar a;\nconsole.log(a) //2\n------------------\n进行如下处理\nvar a;\na = 2;\n变量出现的位置被“移动”到了最上面，这个过程就叫做提升\n```\n变量和函数在内的所有声明都会在任何代码被执行前首先被处理。JavaScript实际会将其看两个声明：var a;和a = 2;第一个定义声明是在编译阶段进行，第二个赋值声明会被留在原地等待执行阶段。\n\n```\nfoo()\nfunction foo() {\n    console.log(a) //undefined\n    var a = 2;\n}\n--------------\n进行如下处理\nfunction foo() {\n    var a;\n    console.log(a) //undefined\n    a = 2;\n}\nfoo()\n```\nfoo函数声明被提升了，但函数表达式却不会被提升。\n```\nfoo() //TypeError\nvar foo = function bar() {\n    //...\n}\n```\n即使是具名函数表达式，名称标识符在赋值之前也无法在所在作用域中使用。\n\n```\nfoo() //1\nvar foo;\nfunction foo() {\n    console.log(1)\n}\nfoo = function() {\n    console.log(2)\n}\n-----------\n进行如下处理\nfunction foo() {\n    console.log(1)\n}\nfoo() //1\nfoo = function() {\n    console.log(2)\n}\n```\n函数声明和变量都会被提升，函数首先被提升，然后才是变量。后面的函数声明还可以覆盖前面的函数声明\n\n```\nfoo() //3\n\nfunction foo() {\n    console.log(1)\n}\n\nvar foo = function() {\n    console.log(2)\n}\n\nfunction foo() {\n    console.log(3)\n}\n```\n\n### 作用域闭包\n> 闭包就是能够读取其他函数内部变量的函数。由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成\"定义在一个函数内部的函数\"。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。\n\n```\nfunction foo() {\n    var a = 2;\n    function bar() {\n        console.log(a)\n    }\n    return bar\n}\nvar baz = bar();\nbaz(); //2\n```\n函数baz()能够访问foo()的内部作用域。将bar()函数本身当作一个值类型进行传递。而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此 \n没有被回收。谁在使用这个内部作用域？原来是  bar() 本身在使用。bar()拥有foo()内部作用域的闭包，该作用域一直存活,bar()本身在使用。bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。\n\n","slug":"2-JS-tishenghebibao","published":1,"updated":"2019-04-01T13:48:24.012Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuowpbrf0007ja6jkmn1pmpo","content":"<h3 id=\"提升和作用域闭包\"><a href=\"#提升和作用域闭包\" class=\"headerlink\" title=\"提升和作用域闭包\"></a>提升和作用域闭包</h3><a id=\"more\"></a>\n<h3 id=\"提升\"><a href=\"#提升\" class=\"headerlink\" title=\"提升\"></a>提升</h3><blockquote>\n<p>这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。<br>可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的<br>最顶端，这个过程被称为提升。<br>声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。<br>要注意避免重复声明，特别是当普通的  var 声明和函数声明混合在一起的时候，否则会引<br>起很多危险的问题！</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = 2;</span><br><span class=\"line\">var a;</span><br><span class=\"line\">console.log(a) //2</span><br><span class=\"line\">------------------</span><br><span class=\"line\">进行如下处理</span><br><span class=\"line\">var a;</span><br><span class=\"line\">a = 2;</span><br><span class=\"line\">变量出现的位置被“移动”到了最上面，这个过程就叫做提升</span><br></pre></td></tr></table></figure>\n<p>变量和函数在内的所有声明都会在任何代码被执行前首先被处理。JavaScript实际会将其看两个声明：var a;和a = 2;第一个定义声明是在编译阶段进行，第二个赋值声明会被留在原地等待执行阶段。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo()</span><br><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">    console.log(a) //undefined</span><br><span class=\"line\">    var a = 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">--------------</span><br><span class=\"line\">进行如下处理</span><br><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">    var a;</span><br><span class=\"line\">    console.log(a) //undefined</span><br><span class=\"line\">    a = 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo()</span><br></pre></td></tr></table></figure>\n<p>foo函数声明被提升了，但函数表达式却不会被提升。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo() //TypeError</span><br><span class=\"line\">var foo = function bar() &#123;</span><br><span class=\"line\">    //...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>即使是具名函数表达式，名称标识符在赋值之前也无法在所在作用域中使用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo() //1</span><br><span class=\"line\">var foo;</span><br><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">    console.log(1)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo = function() &#123;</span><br><span class=\"line\">    console.log(2)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">-----------</span><br><span class=\"line\">进行如下处理</span><br><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">    console.log(1)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo() //1</span><br><span class=\"line\">foo = function() &#123;</span><br><span class=\"line\">    console.log(2)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数声明和变量都会被提升，函数首先被提升，然后才是变量。后面的函数声明还可以覆盖前面的函数声明</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo() //3</span><br><span class=\"line\"></span><br><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">    console.log(1)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var foo = function() &#123;</span><br><span class=\"line\">    console.log(2)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">    console.log(3)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"作用域闭包\"><a href=\"#作用域闭包\" class=\"headerlink\" title=\"作用域闭包\"></a>作用域闭包</h3><blockquote>\n<p>闭包就是能够读取其他函数内部变量的函数。由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">    var a = 2;</span><br><span class=\"line\">    function bar() &#123;</span><br><span class=\"line\">        console.log(a)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return bar</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var baz = bar();</span><br><span class=\"line\">baz(); //2</span><br></pre></td></tr></table></figure>\n<p>函数baz()能够访问foo()的内部作用域。将bar()函数本身当作一个值类型进行传递。而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此<br>没有被回收。谁在使用这个内部作用域？原来是  bar() 本身在使用。bar()拥有foo()内部作用域的闭包，该作用域一直存活,bar()本身在使用。bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"提升和作用域闭包\"><a href=\"#提升和作用域闭包\" class=\"headerlink\" title=\"提升和作用域闭包\"></a>提升和作用域闭包</h3>","more":"<h3 id=\"提升\"><a href=\"#提升\" class=\"headerlink\" title=\"提升\"></a>提升</h3><blockquote>\n<p>这意味着无论作用域中的声明出现在什么地方，都将在代码本身被执行前首先进行处理。<br>可以将这个过程形象地想象成所有的声明（变量和函数）都会被“移动”到各自作用域的<br>最顶端，这个过程被称为提升。<br>声明本身会被提升，而包括函数表达式的赋值在内的赋值操作并不会提升。<br>要注意避免重复声明，特别是当普通的  var 声明和函数声明混合在一起的时候，否则会引<br>起很多危险的问题！</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = 2;</span><br><span class=\"line\">var a;</span><br><span class=\"line\">console.log(a) //2</span><br><span class=\"line\">------------------</span><br><span class=\"line\">进行如下处理</span><br><span class=\"line\">var a;</span><br><span class=\"line\">a = 2;</span><br><span class=\"line\">变量出现的位置被“移动”到了最上面，这个过程就叫做提升</span><br></pre></td></tr></table></figure>\n<p>变量和函数在内的所有声明都会在任何代码被执行前首先被处理。JavaScript实际会将其看两个声明：var a;和a = 2;第一个定义声明是在编译阶段进行，第二个赋值声明会被留在原地等待执行阶段。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo()</span><br><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">    console.log(a) //undefined</span><br><span class=\"line\">    var a = 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">--------------</span><br><span class=\"line\">进行如下处理</span><br><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">    var a;</span><br><span class=\"line\">    console.log(a) //undefined</span><br><span class=\"line\">    a = 2;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo()</span><br></pre></td></tr></table></figure>\n<p>foo函数声明被提升了，但函数表达式却不会被提升。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo() //TypeError</span><br><span class=\"line\">var foo = function bar() &#123;</span><br><span class=\"line\">    //...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>即使是具名函数表达式，名称标识符在赋值之前也无法在所在作用域中使用。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo() //1</span><br><span class=\"line\">var foo;</span><br><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">    console.log(1)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo = function() &#123;</span><br><span class=\"line\">    console.log(2)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">-----------</span><br><span class=\"line\">进行如下处理</span><br><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">    console.log(1)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">foo() //1</span><br><span class=\"line\">foo = function() &#123;</span><br><span class=\"line\">    console.log(2)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>函数声明和变量都会被提升，函数首先被提升，然后才是变量。后面的函数声明还可以覆盖前面的函数声明</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">foo() //3</span><br><span class=\"line\"></span><br><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">    console.log(1)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var foo = function() &#123;</span><br><span class=\"line\">    console.log(2)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">    console.log(3)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"作用域闭包\"><a href=\"#作用域闭包\" class=\"headerlink\" title=\"作用域闭包\"></a>作用域闭包</h3><blockquote>\n<p>闭包就是能够读取其他函数内部变量的函数。由于在Javascript语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">    var a = 2;</span><br><span class=\"line\">    function bar() &#123;</span><br><span class=\"line\">        console.log(a)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return bar</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var baz = bar();</span><br><span class=\"line\">baz(); //2</span><br></pre></td></tr></table></figure>\n<p>函数baz()能够访问foo()的内部作用域。将bar()函数本身当作一个值类型进行传递。而闭包的“神奇”之处正是可以阻止这件事情的发生。事实上内部作用域依然存在，因此<br>没有被回收。谁在使用这个内部作用域？原来是  bar() 本身在使用。bar()拥有foo()内部作用域的闭包，该作用域一直存活,bar()本身在使用。bar() 依然持有对该作用域的引用，而这个引用就叫作闭包。</p>"},{"title":"原始数据类型","date":"2019-03-09T01:01:32.000Z","_content":"### 原始数据类型\n<!-- more -->\n\n### 原始数据类型\n1.JS的类型分为两种，原始数据类型和对象类型。\n2.原始数据类型分为五种，布尔值、数值、字符串、null、undefind、以及ES6中的新类型Symbol。\n\n### TypeScript使用原始类型\n1.布尔值\n```\nlet isDone: boolean = false;\n\n// 编译通过\n// 后面约定，未强调编译错误的代码片段，默认为编译通过\n```\n2.数值\n```\nlet decLiteral: number = 6;\n```\n\n3.字符串\n```\nlet myName:string = 'Tom';\n```\n4.空值\nJavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数：\n```\nfunction alertName(): void {\n    alert('My name is Tom')\n}\n```\n声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null：\n```\nlet unusable: void = undefined;\n```\n\n5.Null 和 Undefined\n在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型：\n```\nlet u: undefined = undefined;\nlet n: null = null;\n```\nundefined 类型的变量只能被赋值为 undefined，null 类型的变量只能被赋值为 null。\n与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：\n```\n// 这样不会报错\nlet num: number = undefined; \nlet u: undefined;\nlet num: number = u;\n```\n而 void 类型的变量不能赋值给 number 类型的变量：\n```\nlet u: void;\nlet num: number = u;\n\n// index.ts(2,5): error TS2322: Type 'void' is not assignable to type 'number'.\n```\n\n\n","source":"_posts/2-ts-primitive-data-type.md","raw":"---\ntitle: 原始数据类型\ndate: 2019-03-09 09:01:32\ntags: ['TypeScript']\ncategories: TypeScript\n---\n### 原始数据类型\n<!-- more -->\n\n### 原始数据类型\n1.JS的类型分为两种，原始数据类型和对象类型。\n2.原始数据类型分为五种，布尔值、数值、字符串、null、undefind、以及ES6中的新类型Symbol。\n\n### TypeScript使用原始类型\n1.布尔值\n```\nlet isDone: boolean = false;\n\n// 编译通过\n// 后面约定，未强调编译错误的代码片段，默认为编译通过\n```\n2.数值\n```\nlet decLiteral: number = 6;\n```\n\n3.字符串\n```\nlet myName:string = 'Tom';\n```\n4.空值\nJavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数：\n```\nfunction alertName(): void {\n    alert('My name is Tom')\n}\n```\n声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null：\n```\nlet unusable: void = undefined;\n```\n\n5.Null 和 Undefined\n在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型：\n```\nlet u: undefined = undefined;\nlet n: null = null;\n```\nundefined 类型的变量只能被赋值为 undefined，null 类型的变量只能被赋值为 null。\n与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：\n```\n// 这样不会报错\nlet num: number = undefined; \nlet u: undefined;\nlet num: number = u;\n```\n而 void 类型的变量不能赋值给 number 类型的变量：\n```\nlet u: void;\nlet num: number = u;\n\n// index.ts(2,5): error TS2322: Type 'void' is not assignable to type 'number'.\n```\n\n\n","slug":"2-ts-primitive-data-type","published":1,"updated":"2019-03-09T01:10:44.471Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuowpbrg0008ja6jkawymq64","content":"<h3 id=\"原始数据类型\"><a href=\"#原始数据类型\" class=\"headerlink\" title=\"原始数据类型\"></a>原始数据类型</h3><a id=\"more\"></a>\n<h3 id=\"原始数据类型-1\"><a href=\"#原始数据类型-1\" class=\"headerlink\" title=\"原始数据类型\"></a>原始数据类型</h3><p>1.JS的类型分为两种，原始数据类型和对象类型。<br>2.原始数据类型分为五种，布尔值、数值、字符串、null、undefind、以及ES6中的新类型Symbol。</p>\n<h3 id=\"TypeScript使用原始类型\"><a href=\"#TypeScript使用原始类型\" class=\"headerlink\" title=\"TypeScript使用原始类型\"></a>TypeScript使用原始类型</h3><p>1.布尔值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let isDone: boolean = false;</span><br><span class=\"line\"></span><br><span class=\"line\">// 编译通过</span><br><span class=\"line\">// 后面约定，未强调编译错误的代码片段，默认为编译通过</span><br></pre></td></tr></table></figure></p>\n<p>2.数值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let decLiteral: number = 6;</span><br></pre></td></tr></table></figure></p>\n<p>3.字符串<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let myName:string = &apos;Tom&apos;;</span><br></pre></td></tr></table></figure></p>\n<p>4.空值<br>JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function alertName(): void &#123;</span><br><span class=\"line\">    alert(&apos;My name is Tom&apos;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let unusable: void = undefined;</span><br></pre></td></tr></table></figure></p>\n<p>5.Null 和 Undefined<br>在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let u: undefined = undefined;</span><br><span class=\"line\">let n: null = null;</span><br></pre></td></tr></table></figure></p>\n<p>undefined 类型的变量只能被赋值为 undefined，null 类型的变量只能被赋值为 null。<br>与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 这样不会报错</span><br><span class=\"line\">let num: number = undefined; </span><br><span class=\"line\">let u: undefined;</span><br><span class=\"line\">let num: number = u;</span><br></pre></td></tr></table></figure></p>\n<p>而 void 类型的变量不能赋值给 number 类型的变量：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let u: void;</span><br><span class=\"line\">let num: number = u;</span><br><span class=\"line\"></span><br><span class=\"line\">// index.ts(2,5): error TS2322: Type &apos;void&apos; is not assignable to type &apos;number&apos;.</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"原始数据类型\"><a href=\"#原始数据类型\" class=\"headerlink\" title=\"原始数据类型\"></a>原始数据类型</h3>","more":"<h3 id=\"原始数据类型-1\"><a href=\"#原始数据类型-1\" class=\"headerlink\" title=\"原始数据类型\"></a>原始数据类型</h3><p>1.JS的类型分为两种，原始数据类型和对象类型。<br>2.原始数据类型分为五种，布尔值、数值、字符串、null、undefind、以及ES6中的新类型Symbol。</p>\n<h3 id=\"TypeScript使用原始类型\"><a href=\"#TypeScript使用原始类型\" class=\"headerlink\" title=\"TypeScript使用原始类型\"></a>TypeScript使用原始类型</h3><p>1.布尔值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let isDone: boolean = false;</span><br><span class=\"line\"></span><br><span class=\"line\">// 编译通过</span><br><span class=\"line\">// 后面约定，未强调编译错误的代码片段，默认为编译通过</span><br></pre></td></tr></table></figure></p>\n<p>2.数值<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let decLiteral: number = 6;</span><br></pre></td></tr></table></figure></p>\n<p>3.字符串<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let myName:string = &apos;Tom&apos;;</span><br></pre></td></tr></table></figure></p>\n<p>4.空值<br>JavaScript 没有空值（Void）的概念，在 TypeScript 中，可以用 void 表示没有任何返回值的函数：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function alertName(): void &#123;</span><br><span class=\"line\">    alert(&apos;My name is Tom&apos;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let unusable: void = undefined;</span><br></pre></td></tr></table></figure></p>\n<p>5.Null 和 Undefined<br>在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let u: undefined = undefined;</span><br><span class=\"line\">let n: null = null;</span><br></pre></td></tr></table></figure></p>\n<p>undefined 类型的变量只能被赋值为 undefined，null 类型的变量只能被赋值为 null。<br>与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 这样不会报错</span><br><span class=\"line\">let num: number = undefined; </span><br><span class=\"line\">let u: undefined;</span><br><span class=\"line\">let num: number = u;</span><br></pre></td></tr></table></figure></p>\n<p>而 void 类型的变量不能赋值给 number 类型的变量：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let u: void;</span><br><span class=\"line\">let num: number = u;</span><br><span class=\"line\"></span><br><span class=\"line\">// index.ts(2,5): error TS2322: Type &apos;void&apos; is not assignable to type &apos;number&apos;.</span><br></pre></td></tr></table></figure></p>"},{"title":"this","date":"2019-04-01T16:00:00.000Z","_content":"### 关于this\n<!-- more -->\n\n> this 既不指向函数自身也不指向函数的词法作用域。this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。\n\n### this是什么\n当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包 \n含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。this 就是记录的 \n其中一个属性，会在函数执行的过程中用到。\n\n### this绑定\n1.默认绑定\n```\nfunction foo() {\n    console.log(this.a)\n}\nvar a = 2;\nfoo() //2\n```\n调用foo()，this.a被解析成全局变量a。函数调用时应用了this的默认绑定,this指向全局对象。\n如何判断默认绑定？在代码中，foo() 是直接使用不带任何修饰的函数引用进行调用的，因此只能使用 \n默认绑定，无法应用其他规则。\n严格模式下this是undefined。\n\n2.隐式绑定\n```\nfunction foo() {\n    console.log(this)\n}\nvar obj = {\n    a: 2,\n    foo:foo\n}\nvar a  = 3;\nobj.foo() //2\n```\nfoo()是被当作引用属性添加到 obj 中的。\n调用位置会使用obj上下文引用函数，foo()调用时指向obj对象，隐式规则会把函数调用中的this绑定到这个上下文对象\n\n3.显式绑定\n```\nfunction foo() { \n    console.log( this.a ); \n} \nvar obj = { \n    a:2 \n}; \nvar a = 3;\nfoo.call( obj ); // 2\n```\n通过  foo.call(..)，我们可以在调用  foo 时强制把它的  this 绑定到  obj 上。\n从  this 绑定的角度来说，call(..) 和  apply(..) 是一样的，它们的区别体现 \n在其他的参数上。\n\n4.new绑定\n使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。\n1.创建（或者说构造）一个全新的对象。 \n2.这个新对象会被执行  [[ 原型  ]] 连接。 \n3.这个新对象会绑定到函数调用的 this。 \n4.如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。\n\n---\n```\nfunction foo(a) { \n    this.a = a; \n} \nvar bar = new foo(2); \nconsole.log( bar.a ); // 2\n```\n使用  new 来调用  foo(..) 时，我们会构造一个新对象并把它绑定到  foo(..) 调用中的  this \n上。new 是最后一种可以影响函数调用时  this 绑定行为的方法，我们称之为  new 绑定。\n\n### 箭头函数\n> 箭头函数根据外层（函数或者全局）作用域来决定 this。 \n\n```\nfunction foo() { \n    // 返回一个箭头函数 \n    return (a) => { \n        //this 继承自foo() \n        console.log( this.a ); \n    }; \n} \nvar obj1 = { \n    a:2 \n};\nvar obj2 = { \n    a:3\n};\nvar bar = foo.call(obj1)\nbar.call(obj2) //2 不是3\n```\n箭头函数会捕获调用时foo()到this,foo()的this绑定obj1，this也绑定到obj1。\n箭头函数的绑定无法被修改\n\n### 判断this\n1.  函数是否在 new 中调用（new 绑定）？如果是的话  this 绑定的是新创建的对象。 \n    var bar = new foo() \n2.  函数是否通过  call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是指定的对象。\n    var bar = foo.call(obj2) \n3.  函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象。  \n    var bar = obj1.foo() \n4.  如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到全局对象。 \n    var bar = foo()\n\n","source":"_posts/3-JS-this.md","raw":"---\ntitle: this\ndate: 2019-04-02\ntags: ['你不知道的JavaScript']\ncategories: 你不知道的JavaScript\n---\n### 关于this\n<!-- more -->\n\n> this 既不指向函数自身也不指向函数的词法作用域。this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。\n\n### this是什么\n当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包 \n含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。this 就是记录的 \n其中一个属性，会在函数执行的过程中用到。\n\n### this绑定\n1.默认绑定\n```\nfunction foo() {\n    console.log(this.a)\n}\nvar a = 2;\nfoo() //2\n```\n调用foo()，this.a被解析成全局变量a。函数调用时应用了this的默认绑定,this指向全局对象。\n如何判断默认绑定？在代码中，foo() 是直接使用不带任何修饰的函数引用进行调用的，因此只能使用 \n默认绑定，无法应用其他规则。\n严格模式下this是undefined。\n\n2.隐式绑定\n```\nfunction foo() {\n    console.log(this)\n}\nvar obj = {\n    a: 2,\n    foo:foo\n}\nvar a  = 3;\nobj.foo() //2\n```\nfoo()是被当作引用属性添加到 obj 中的。\n调用位置会使用obj上下文引用函数，foo()调用时指向obj对象，隐式规则会把函数调用中的this绑定到这个上下文对象\n\n3.显式绑定\n```\nfunction foo() { \n    console.log( this.a ); \n} \nvar obj = { \n    a:2 \n}; \nvar a = 3;\nfoo.call( obj ); // 2\n```\n通过  foo.call(..)，我们可以在调用  foo 时强制把它的  this 绑定到  obj 上。\n从  this 绑定的角度来说，call(..) 和  apply(..) 是一样的，它们的区别体现 \n在其他的参数上。\n\n4.new绑定\n使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。\n1.创建（或者说构造）一个全新的对象。 \n2.这个新对象会被执行  [[ 原型  ]] 连接。 \n3.这个新对象会绑定到函数调用的 this。 \n4.如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。\n\n---\n```\nfunction foo(a) { \n    this.a = a; \n} \nvar bar = new foo(2); \nconsole.log( bar.a ); // 2\n```\n使用  new 来调用  foo(..) 时，我们会构造一个新对象并把它绑定到  foo(..) 调用中的  this \n上。new 是最后一种可以影响函数调用时  this 绑定行为的方法，我们称之为  new 绑定。\n\n### 箭头函数\n> 箭头函数根据外层（函数或者全局）作用域来决定 this。 \n\n```\nfunction foo() { \n    // 返回一个箭头函数 \n    return (a) => { \n        //this 继承自foo() \n        console.log( this.a ); \n    }; \n} \nvar obj1 = { \n    a:2 \n};\nvar obj2 = { \n    a:3\n};\nvar bar = foo.call(obj1)\nbar.call(obj2) //2 不是3\n```\n箭头函数会捕获调用时foo()到this,foo()的this绑定obj1，this也绑定到obj1。\n箭头函数的绑定无法被修改\n\n### 判断this\n1.  函数是否在 new 中调用（new 绑定）？如果是的话  this 绑定的是新创建的对象。 \n    var bar = new foo() \n2.  函数是否通过  call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是指定的对象。\n    var bar = foo.call(obj2) \n3.  函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象。  \n    var bar = obj1.foo() \n4.  如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到全局对象。 \n    var bar = foo()\n\n","slug":"3-JS-this","published":1,"updated":"2019-04-02T11:13:27.854Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuowpbrk000cja6jksjy6ihu","content":"<h3 id=\"关于this\"><a href=\"#关于this\" class=\"headerlink\" title=\"关于this\"></a>关于this</h3><a id=\"more\"></a>\n<blockquote>\n<p>this 既不指向函数自身也不指向函数的词法作用域。this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。</p>\n</blockquote>\n<h3 id=\"this是什么\"><a href=\"#this是什么\" class=\"headerlink\" title=\"this是什么\"></a>this是什么</h3><p>当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包<br>含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。this 就是记录的<br>其中一个属性，会在函数执行的过程中用到。</p>\n<h3 id=\"this绑定\"><a href=\"#this绑定\" class=\"headerlink\" title=\"this绑定\"></a>this绑定</h3><p>1.默认绑定<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">    console.log(this.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var a = 2;</span><br><span class=\"line\">foo() //2</span><br></pre></td></tr></table></figure></p>\n<p>调用foo()，this.a被解析成全局变量a。函数调用时应用了this的默认绑定,this指向全局对象。<br>如何判断默认绑定？在代码中，foo() 是直接使用不带任何修饰的函数引用进行调用的，因此只能使用<br>默认绑定，无法应用其他规则。<br>严格模式下this是undefined。</p>\n<p>2.隐式绑定<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">    console.log(this)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    a: 2,</span><br><span class=\"line\">    foo:foo</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var a  = 3;</span><br><span class=\"line\">obj.foo() //2</span><br></pre></td></tr></table></figure></p>\n<p>foo()是被当作引用属性添加到 obj 中的。<br>调用位置会使用obj上下文引用函数，foo()调用时指向obj对象，隐式规则会把函数调用中的this绑定到这个上下文对象</p>\n<p>3.显式绑定<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123; </span><br><span class=\"line\">    console.log( this.a ); </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">var obj = &#123; </span><br><span class=\"line\">    a:2 </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">var a = 3;</span><br><span class=\"line\">foo.call( obj ); // 2</span><br></pre></td></tr></table></figure></p>\n<p>通过  foo.call(..)，我们可以在调用  foo 时强制把它的  this 绑定到  obj 上。<br>从  this 绑定的角度来说，call(..) 和  apply(..) 是一样的，它们的区别体现<br>在其他的参数上。</p>\n<p>4.new绑定<br>使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。<br>1.创建（或者说构造）一个全新的对象。<br>2.这个新对象会被执行  [[ 原型  ]] 连接。<br>3.这个新对象会绑定到函数调用的 this。<br>4.如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。</p>\n<hr>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo(a) &#123; </span><br><span class=\"line\">    this.a = a; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">var bar = new foo(2); </span><br><span class=\"line\">console.log( bar.a ); // 2</span><br></pre></td></tr></table></figure>\n<p>使用  new 来调用  foo(..) 时，我们会构造一个新对象并把它绑定到  foo(..) 调用中的  this<br>上。new 是最后一种可以影响函数调用时  this 绑定行为的方法，我们称之为  new 绑定。</p>\n<h3 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h3><blockquote>\n<p>箭头函数根据外层（函数或者全局）作用域来决定 this。 </p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123; </span><br><span class=\"line\">    // 返回一个箭头函数 </span><br><span class=\"line\">    return (a) =&gt; &#123; </span><br><span class=\"line\">        //this 继承自foo() </span><br><span class=\"line\">        console.log( this.a ); </span><br><span class=\"line\">    &#125;; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">var obj1 = &#123; </span><br><span class=\"line\">    a:2 </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var obj2 = &#123; </span><br><span class=\"line\">    a:3</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var bar = foo.call(obj1)</span><br><span class=\"line\">bar.call(obj2) //2 不是3</span><br></pre></td></tr></table></figure>\n<p>箭头函数会捕获调用时foo()到this,foo()的this绑定obj1，this也绑定到obj1。<br>箭头函数的绑定无法被修改</p>\n<h3 id=\"判断this\"><a href=\"#判断this\" class=\"headerlink\" title=\"判断this\"></a>判断this</h3><ol>\n<li>函数是否在 new 中调用（new 绑定）？如果是的话  this 绑定的是新创建的对象。<br>var bar = new foo() </li>\n<li>函数是否通过  call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是指定的对象。<br>var bar = foo.call(obj2) </li>\n<li>函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象。<br>var bar = obj1.foo() </li>\n<li>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到全局对象。<br>var bar = foo()</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"关于this\"><a href=\"#关于this\" class=\"headerlink\" title=\"关于this\"></a>关于this</h3>","more":"<blockquote>\n<p>this 既不指向函数自身也不指向函数的词法作用域。this 实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。</p>\n</blockquote>\n<h3 id=\"this是什么\"><a href=\"#this是什么\" class=\"headerlink\" title=\"this是什么\"></a>this是什么</h3><p>当一个函数被调用时，会创建一个活动记录（有时候也称为执行上下文）。这个记录会包<br>含函数在哪里被调用（调用栈）、函数的调用方法、传入的参数等信息。this 就是记录的<br>其中一个属性，会在函数执行的过程中用到。</p>\n<h3 id=\"this绑定\"><a href=\"#this绑定\" class=\"headerlink\" title=\"this绑定\"></a>this绑定</h3><p>1.默认绑定<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">    console.log(this.a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var a = 2;</span><br><span class=\"line\">foo() //2</span><br></pre></td></tr></table></figure></p>\n<p>调用foo()，this.a被解析成全局变量a。函数调用时应用了this的默认绑定,this指向全局对象。<br>如何判断默认绑定？在代码中，foo() 是直接使用不带任何修饰的函数引用进行调用的，因此只能使用<br>默认绑定，无法应用其他规则。<br>严格模式下this是undefined。</p>\n<p>2.隐式绑定<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">    console.log(this)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    a: 2,</span><br><span class=\"line\">    foo:foo</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var a  = 3;</span><br><span class=\"line\">obj.foo() //2</span><br></pre></td></tr></table></figure></p>\n<p>foo()是被当作引用属性添加到 obj 中的。<br>调用位置会使用obj上下文引用函数，foo()调用时指向obj对象，隐式规则会把函数调用中的this绑定到这个上下文对象</p>\n<p>3.显式绑定<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123; </span><br><span class=\"line\">    console.log( this.a ); </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">var obj = &#123; </span><br><span class=\"line\">    a:2 </span><br><span class=\"line\">&#125;; </span><br><span class=\"line\">var a = 3;</span><br><span class=\"line\">foo.call( obj ); // 2</span><br></pre></td></tr></table></figure></p>\n<p>通过  foo.call(..)，我们可以在调用  foo 时强制把它的  this 绑定到  obj 上。<br>从  this 绑定的角度来说，call(..) 和  apply(..) 是一样的，它们的区别体现<br>在其他的参数上。</p>\n<p>4.new绑定<br>使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。<br>1.创建（或者说构造）一个全新的对象。<br>2.这个新对象会被执行  [[ 原型  ]] 连接。<br>3.这个新对象会绑定到函数调用的 this。<br>4.如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。</p>\n<hr>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo(a) &#123; </span><br><span class=\"line\">    this.a = a; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">var bar = new foo(2); </span><br><span class=\"line\">console.log( bar.a ); // 2</span><br></pre></td></tr></table></figure>\n<p>使用  new 来调用  foo(..) 时，我们会构造一个新对象并把它绑定到  foo(..) 调用中的  this<br>上。new 是最后一种可以影响函数调用时  this 绑定行为的方法，我们称之为  new 绑定。</p>\n<h3 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h3><blockquote>\n<p>箭头函数根据外层（函数或者全局）作用域来决定 this。 </p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123; </span><br><span class=\"line\">    // 返回一个箭头函数 </span><br><span class=\"line\">    return (a) =&gt; &#123; </span><br><span class=\"line\">        //this 继承自foo() </span><br><span class=\"line\">        console.log( this.a ); </span><br><span class=\"line\">    &#125;; </span><br><span class=\"line\">&#125; </span><br><span class=\"line\">var obj1 = &#123; </span><br><span class=\"line\">    a:2 </span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var obj2 = &#123; </span><br><span class=\"line\">    a:3</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">var bar = foo.call(obj1)</span><br><span class=\"line\">bar.call(obj2) //2 不是3</span><br></pre></td></tr></table></figure>\n<p>箭头函数会捕获调用时foo()到this,foo()的this绑定obj1，this也绑定到obj1。<br>箭头函数的绑定无法被修改</p>\n<h3 id=\"判断this\"><a href=\"#判断this\" class=\"headerlink\" title=\"判断this\"></a>判断this</h3><ol>\n<li>函数是否在 new 中调用（new 绑定）？如果是的话  this 绑定的是新创建的对象。<br>var bar = new foo() </li>\n<li>函数是否通过  call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是指定的对象。<br>var bar = foo.call(obj2) </li>\n<li>函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象。<br>var bar = obj1.foo() </li>\n<li>如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到全局对象。<br>var bar = foo()</li>\n</ol>"},{"title":"任意值Any","date":"2019-03-09T01:14:46.000Z","_content":"### 任意值Any\n<!-- more -->\n\n### 任意值Any\n任意值（Any）用来表示允许赋值为任意类型。\n1.如果是一个普通类型，在赋值过程中改变类型是不被允许的。\n2.如果是一个any类型,则允许被赋值为任意类型。\n```\nlet myFavoriteNumber:any = 'seven';\nmyFavoriteNumber = 7;\n```\n\n### 任意值的属性和方法\n1. 在任意值上访问任何属性都是允许的：\n2. 也允许调用任何方法：\n```\nlet anyThing: any = 'hello';\nconsole.log(anyThing.myName);\n\nlet anyThing: any = 'Tom';\nanyThing.setName('Jerry');\n```\n\n### 未声明类型的变量\n变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型：\n```\nlet something;\nsomething = 'seven';\n```\n\n","source":"_posts/3-ts-any.md","raw":"---\ntitle: 任意值Any\ndate: 2019-03-09 09:14:46\ntags: ['TypeScript']\ncategories: TypeScript\n---\n### 任意值Any\n<!-- more -->\n\n### 任意值Any\n任意值（Any）用来表示允许赋值为任意类型。\n1.如果是一个普通类型，在赋值过程中改变类型是不被允许的。\n2.如果是一个any类型,则允许被赋值为任意类型。\n```\nlet myFavoriteNumber:any = 'seven';\nmyFavoriteNumber = 7;\n```\n\n### 任意值的属性和方法\n1. 在任意值上访问任何属性都是允许的：\n2. 也允许调用任何方法：\n```\nlet anyThing: any = 'hello';\nconsole.log(anyThing.myName);\n\nlet anyThing: any = 'Tom';\nanyThing.setName('Jerry');\n```\n\n### 未声明类型的变量\n变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型：\n```\nlet something;\nsomething = 'seven';\n```\n\n","slug":"3-ts-any","published":1,"updated":"2019-03-09T01:19:56.750Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuowpbrn000eja6j6lqy358e","content":"<h3 id=\"任意值Any\"><a href=\"#任意值Any\" class=\"headerlink\" title=\"任意值Any\"></a>任意值Any</h3><a id=\"more\"></a>\n<h3 id=\"任意值Any-1\"><a href=\"#任意值Any-1\" class=\"headerlink\" title=\"任意值Any\"></a>任意值Any</h3><p>任意值（Any）用来表示允许赋值为任意类型。<br>1.如果是一个普通类型，在赋值过程中改变类型是不被允许的。<br>2.如果是一个any类型,则允许被赋值为任意类型。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let myFavoriteNumber:any = &apos;seven&apos;;</span><br><span class=\"line\">myFavoriteNumber = 7;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"任意值的属性和方法\"><a href=\"#任意值的属性和方法\" class=\"headerlink\" title=\"任意值的属性和方法\"></a>任意值的属性和方法</h3><ol>\n<li>在任意值上访问任何属性都是允许的：</li>\n<li>也允许调用任何方法：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let anyThing: any = &apos;hello&apos;;</span><br><span class=\"line\">console.log(anyThing.myName);</span><br><span class=\"line\"></span><br><span class=\"line\">let anyThing: any = &apos;Tom&apos;;</span><br><span class=\"line\">anyThing.setName(&apos;Jerry&apos;);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"未声明类型的变量\"><a href=\"#未声明类型的变量\" class=\"headerlink\" title=\"未声明类型的变量\"></a>未声明类型的变量</h3><p>变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let something;</span><br><span class=\"line\">something = &apos;seven&apos;;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"任意值Any\"><a href=\"#任意值Any\" class=\"headerlink\" title=\"任意值Any\"></a>任意值Any</h3>","more":"<h3 id=\"任意值Any-1\"><a href=\"#任意值Any-1\" class=\"headerlink\" title=\"任意值Any\"></a>任意值Any</h3><p>任意值（Any）用来表示允许赋值为任意类型。<br>1.如果是一个普通类型，在赋值过程中改变类型是不被允许的。<br>2.如果是一个any类型,则允许被赋值为任意类型。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let myFavoriteNumber:any = &apos;seven&apos;;</span><br><span class=\"line\">myFavoriteNumber = 7;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"任意值的属性和方法\"><a href=\"#任意值的属性和方法\" class=\"headerlink\" title=\"任意值的属性和方法\"></a>任意值的属性和方法</h3><ol>\n<li>在任意值上访问任何属性都是允许的：</li>\n<li>也允许调用任何方法：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let anyThing: any = &apos;hello&apos;;</span><br><span class=\"line\">console.log(anyThing.myName);</span><br><span class=\"line\"></span><br><span class=\"line\">let anyThing: any = &apos;Tom&apos;;</span><br><span class=\"line\">anyThing.setName(&apos;Jerry&apos;);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"未声明类型的变量\"><a href=\"#未声明类型的变量\" class=\"headerlink\" title=\"未声明类型的变量\"></a>未声明类型的变量</h3><p>变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let something;</span><br><span class=\"line\">something = &apos;seven&apos;;</span><br></pre></td></tr></table></figure></p>"},{"title":"对象的类型——接口","date":"2019-03-09T01:27:54.000Z","_content":"### 对象的类型(interfacer)\n<!-- more -->\n\n### 什么是接口\n对行为的抽象，而具体如何行动需要由类去实现。TypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述。\n```\n//定义接口\ninterface Person {\n    name:string;\n    age: number;\n}\n\n//定义一个变量，类型是Person。约束了 tom 的形状必须和接口 Person 一致。接口少了一些属性是不允许的，多一些属性也是不允许的。\nlet tom:Person = {\n    name: 'Tom',\n    age: 25\n}\n```\n\n### 可选属性\n有时不需要匹配所有的属性，可以用可选属性。定义属性key后面加? 如key?\n```\n//定义接口\ninterface Person {\n    name:string;\n    age？: number;\n}\n\n//这时仍然不允许添加未定义的属性：\nlet tom: Person = {\n    name: 'Tom'\n};\n```\n\n### 任意属性\n1.使用 [propName: string] 定义了任意属性取 string 类型的值。\n2.一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集，负责报错。\n\n```\ninterface Person {\n    name: string;\n    age?: number;\n    [propName: string]: any;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    gender: 'male'\n};\n```\n```\n//报错\ninterface Person {\n    name: string;\n    age?: number;\n    [propName: string]: string;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    age: 25,\n    gender: 'male'\n};\n```\n因为可选属性age的值是number,number 不是 string 的子属性，所以报错了。\n\n### 可读属性\n1.readonly 定义只读属性：\n2.注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候：\n```\n//报错\ninterface Person {\n    readonly id: number;\n    name: string;\n    age?: number;\n    [propName: string]: any;\n}\n\nlet tom: Person = {\n    id: 89757,\n    name: 'Tom',\n    gender: 'male'\n};\n\ntom.id = 9527;\n```\n使用 readonly 定义的属性 id 初始化后，又被赋值了，所以报错了。\n\n```\ninterface Person {\n    readonly id: number;\n    name: string;\n    age?: number;\n    [propName: string]: any;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    gender: 'male'\n};\n\ntom.id = 89757;\n```\n报错如下：\n1. tom 进行赋值的时候，没有给 id 赋值。\n2.  tom.id 赋值的时候，由于它是只读属性","source":"_posts/4-ts-interfaces.md","raw":"---\ntitle: 对象的类型——接口\ndate: 2019-03-09 09:27:54\ntags: ['TypeScript']\ncategories: TypeScript\n---\n### 对象的类型(interfacer)\n<!-- more -->\n\n### 什么是接口\n对行为的抽象，而具体如何行动需要由类去实现。TypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述。\n```\n//定义接口\ninterface Person {\n    name:string;\n    age: number;\n}\n\n//定义一个变量，类型是Person。约束了 tom 的形状必须和接口 Person 一致。接口少了一些属性是不允许的，多一些属性也是不允许的。\nlet tom:Person = {\n    name: 'Tom',\n    age: 25\n}\n```\n\n### 可选属性\n有时不需要匹配所有的属性，可以用可选属性。定义属性key后面加? 如key?\n```\n//定义接口\ninterface Person {\n    name:string;\n    age？: number;\n}\n\n//这时仍然不允许添加未定义的属性：\nlet tom: Person = {\n    name: 'Tom'\n};\n```\n\n### 任意属性\n1.使用 [propName: string] 定义了任意属性取 string 类型的值。\n2.一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集，负责报错。\n\n```\ninterface Person {\n    name: string;\n    age?: number;\n    [propName: string]: any;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    gender: 'male'\n};\n```\n```\n//报错\ninterface Person {\n    name: string;\n    age?: number;\n    [propName: string]: string;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    age: 25,\n    gender: 'male'\n};\n```\n因为可选属性age的值是number,number 不是 string 的子属性，所以报错了。\n\n### 可读属性\n1.readonly 定义只读属性：\n2.注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候：\n```\n//报错\ninterface Person {\n    readonly id: number;\n    name: string;\n    age?: number;\n    [propName: string]: any;\n}\n\nlet tom: Person = {\n    id: 89757,\n    name: 'Tom',\n    gender: 'male'\n};\n\ntom.id = 9527;\n```\n使用 readonly 定义的属性 id 初始化后，又被赋值了，所以报错了。\n\n```\ninterface Person {\n    readonly id: number;\n    name: string;\n    age?: number;\n    [propName: string]: any;\n}\n\nlet tom: Person = {\n    name: 'Tom',\n    gender: 'male'\n};\n\ntom.id = 89757;\n```\n报错如下：\n1. tom 进行赋值的时候，没有给 id 赋值。\n2.  tom.id 赋值的时候，由于它是只读属性","slug":"4-ts-interfaces","published":1,"updated":"2019-03-09T01:48:13.038Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuowpbrq000jja6j1rtqa0cp","content":"<h3 id=\"对象的类型-interfacer\"><a href=\"#对象的类型-interfacer\" class=\"headerlink\" title=\"对象的类型(interfacer)\"></a>对象的类型(interfacer)</h3><a id=\"more\"></a>\n<h3 id=\"什么是接口\"><a href=\"#什么是接口\" class=\"headerlink\" title=\"什么是接口\"></a>什么是接口</h3><p>对行为的抽象，而具体如何行动需要由类去实现。TypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//定义接口</span><br><span class=\"line\">interface Person &#123;</span><br><span class=\"line\">    name:string;</span><br><span class=\"line\">    age: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//定义一个变量，类型是Person。约束了 tom 的形状必须和接口 Person 一致。接口少了一些属性是不允许的，多一些属性也是不允许的。</span><br><span class=\"line\">let tom:Person = &#123;</span><br><span class=\"line\">    name: &apos;Tom&apos;,</span><br><span class=\"line\">    age: 25</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"可选属性\"><a href=\"#可选属性\" class=\"headerlink\" title=\"可选属性\"></a>可选属性</h3><p>有时不需要匹配所有的属性，可以用可选属性。定义属性key后面加? 如key?<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//定义接口</span><br><span class=\"line\">interface Person &#123;</span><br><span class=\"line\">    name:string;</span><br><span class=\"line\">    age？: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//这时仍然不允许添加未定义的属性：</span><br><span class=\"line\">let tom: Person = &#123;</span><br><span class=\"line\">    name: &apos;Tom&apos;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"任意属性\"><a href=\"#任意属性\" class=\"headerlink\" title=\"任意属性\"></a>任意属性</h3><p>1.使用 [propName: string] 定义了任意属性取 string 类型的值。<br>2.一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集，负责报错。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Person &#123;</span><br><span class=\"line\">    name: string;</span><br><span class=\"line\">    age?: number;</span><br><span class=\"line\">    [propName: string]: any;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let tom: Person = &#123;</span><br><span class=\"line\">    name: &apos;Tom&apos;,</span><br><span class=\"line\">    gender: &apos;male&apos;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//报错</span><br><span class=\"line\">interface Person &#123;</span><br><span class=\"line\">    name: string;</span><br><span class=\"line\">    age?: number;</span><br><span class=\"line\">    [propName: string]: string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let tom: Person = &#123;</span><br><span class=\"line\">    name: &apos;Tom&apos;,</span><br><span class=\"line\">    age: 25,</span><br><span class=\"line\">    gender: &apos;male&apos;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>因为可选属性age的值是number,number 不是 string 的子属性，所以报错了。</p>\n<h3 id=\"可读属性\"><a href=\"#可读属性\" class=\"headerlink\" title=\"可读属性\"></a>可读属性</h3><p>1.readonly 定义只读属性：<br>2.注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//报错</span><br><span class=\"line\">interface Person &#123;</span><br><span class=\"line\">    readonly id: number;</span><br><span class=\"line\">    name: string;</span><br><span class=\"line\">    age?: number;</span><br><span class=\"line\">    [propName: string]: any;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let tom: Person = &#123;</span><br><span class=\"line\">    id: 89757,</span><br><span class=\"line\">    name: &apos;Tom&apos;,</span><br><span class=\"line\">    gender: &apos;male&apos;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">tom.id = 9527;</span><br></pre></td></tr></table></figure></p>\n<p>使用 readonly 定义的属性 id 初始化后，又被赋值了，所以报错了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Person &#123;</span><br><span class=\"line\">    readonly id: number;</span><br><span class=\"line\">    name: string;</span><br><span class=\"line\">    age?: number;</span><br><span class=\"line\">    [propName: string]: any;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let tom: Person = &#123;</span><br><span class=\"line\">    name: &apos;Tom&apos;,</span><br><span class=\"line\">    gender: &apos;male&apos;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">tom.id = 89757;</span><br></pre></td></tr></table></figure>\n<p>报错如下：</p>\n<ol>\n<li>tom 进行赋值的时候，没有给 id 赋值。</li>\n<li>tom.id 赋值的时候，由于它是只读属性</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"对象的类型-interfacer\"><a href=\"#对象的类型-interfacer\" class=\"headerlink\" title=\"对象的类型(interfacer)\"></a>对象的类型(interfacer)</h3>","more":"<h3 id=\"什么是接口\"><a href=\"#什么是接口\" class=\"headerlink\" title=\"什么是接口\"></a>什么是接口</h3><p>对行为的抽象，而具体如何行动需要由类去实现。TypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//定义接口</span><br><span class=\"line\">interface Person &#123;</span><br><span class=\"line\">    name:string;</span><br><span class=\"line\">    age: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//定义一个变量，类型是Person。约束了 tom 的形状必须和接口 Person 一致。接口少了一些属性是不允许的，多一些属性也是不允许的。</span><br><span class=\"line\">let tom:Person = &#123;</span><br><span class=\"line\">    name: &apos;Tom&apos;,</span><br><span class=\"line\">    age: 25</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"可选属性\"><a href=\"#可选属性\" class=\"headerlink\" title=\"可选属性\"></a>可选属性</h3><p>有时不需要匹配所有的属性，可以用可选属性。定义属性key后面加? 如key?<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//定义接口</span><br><span class=\"line\">interface Person &#123;</span><br><span class=\"line\">    name:string;</span><br><span class=\"line\">    age？: number;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//这时仍然不允许添加未定义的属性：</span><br><span class=\"line\">let tom: Person = &#123;</span><br><span class=\"line\">    name: &apos;Tom&apos;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"任意属性\"><a href=\"#任意属性\" class=\"headerlink\" title=\"任意属性\"></a>任意属性</h3><p>1.使用 [propName: string] 定义了任意属性取 string 类型的值。<br>2.一旦定义了任意属性，那么确定属性和可选属性的类型都必须是它的类型的子集，负责报错。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Person &#123;</span><br><span class=\"line\">    name: string;</span><br><span class=\"line\">    age?: number;</span><br><span class=\"line\">    [propName: string]: any;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let tom: Person = &#123;</span><br><span class=\"line\">    name: &apos;Tom&apos;,</span><br><span class=\"line\">    gender: &apos;male&apos;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//报错</span><br><span class=\"line\">interface Person &#123;</span><br><span class=\"line\">    name: string;</span><br><span class=\"line\">    age?: number;</span><br><span class=\"line\">    [propName: string]: string;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let tom: Person = &#123;</span><br><span class=\"line\">    name: &apos;Tom&apos;,</span><br><span class=\"line\">    age: 25,</span><br><span class=\"line\">    gender: &apos;male&apos;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n<p>因为可选属性age的值是number,number 不是 string 的子属性，所以报错了。</p>\n<h3 id=\"可读属性\"><a href=\"#可读属性\" class=\"headerlink\" title=\"可读属性\"></a>可读属性</h3><p>1.readonly 定义只读属性：<br>2.注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//报错</span><br><span class=\"line\">interface Person &#123;</span><br><span class=\"line\">    readonly id: number;</span><br><span class=\"line\">    name: string;</span><br><span class=\"line\">    age?: number;</span><br><span class=\"line\">    [propName: string]: any;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let tom: Person = &#123;</span><br><span class=\"line\">    id: 89757,</span><br><span class=\"line\">    name: &apos;Tom&apos;,</span><br><span class=\"line\">    gender: &apos;male&apos;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">tom.id = 9527;</span><br></pre></td></tr></table></figure></p>\n<p>使用 readonly 定义的属性 id 初始化后，又被赋值了，所以报错了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">interface Person &#123;</span><br><span class=\"line\">    readonly id: number;</span><br><span class=\"line\">    name: string;</span><br><span class=\"line\">    age?: number;</span><br><span class=\"line\">    [propName: string]: any;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let tom: Person = &#123;</span><br><span class=\"line\">    name: &apos;Tom&apos;,</span><br><span class=\"line\">    gender: &apos;male&apos;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">tom.id = 89757;</span><br></pre></td></tr></table></figure>\n<p>报错如下：</p>\n<ol>\n<li>tom 进行赋值的时候，没有给 id 赋值。</li>\n<li>tom.id 赋值的时候，由于它是只读属性</li>\n</ol>"},{"title":"JavaScript 的 async/await","date":"2018-12-27T16:00:00.000Z","_content":"\n\n\n### 什么是async、await\n<!-- more -->\n\nasync 是“异步”的简写，而 await 可以认为是 async wait 的简写。所以应该很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。\n\n### async\n1.async用法，它作为一个关键字放到函数前面，用于表示函数是一个异步函数，因为async就是异步的意思， 异步函数也就意味着该函数的执行不会阻塞后面代码的执行。 写一个async 函数\n```\nasync function test() {\n    return \"hello world\"\n}\n```\n2.语法就是在函数前面加上async关键字，用来表示它是异步的，怎么调用呢？async 函数也是函数，平时我们怎么使用函数就怎么使用它，直接加括号调用就可以了，为了表示它没有阻塞它后面代码的执行。\n```\nconsole.log(test())\n//输出的是一个Promisea对象\n\nPromise\n__proto__: Promise\n[[PromiseStatus]]: \"resolved\"\n[[PromiseValue]]: \"hell\"\n```\n\n3.async 函数返回的是一个 Promise 对象。从文档中也可以得到这个信息。async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。\n\n### await\n1.一般来说，都认为 await 是在等待一个 async 函数完成。不过按语法说明，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。\n\n2.async函数返回的是一个Promise对象，所以await可以用于等待一个async函数的返回值，await就是等待async的返回值。\n\n```\nfunction test1() {\n    reuturn \"test1\"\n}\nfunction test2() {\n    reuturn \"test2\"\n}\nasync function test() {\n    const v1 = await test1();\n    const v2 = await test2();\n}\ntest()\n```\n\n3.async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。\n\n### async/await 干了啥\n1.async会将其后的函数的返回值封装成一个Promise对象，而await会等待这个Promise完成，并将其resolve的结果返回出来。\n\n2.async/await 的优势在于处理 then 链，单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了\n```\n/**\n * 传入参数 n，表示这个函数执行的时间（毫秒）\n * 执行的结果是 n + 200，这个值将用于下一步骤\n */\nfunction takeLongTime(n) {\n    return new Promise(resolve => {\n        setTimeout(() => resolve(n + 200), n);\n    });\n}\n\nfunction step1(n) {\n    console.log(`step1 with ${n}`);\n    return takeLongTime(n);\n}\n\nfunction step2(n) {\n    console.log(`step2 with ${n}`);\n    return takeLongTime(n);\n}\n\nfunction step3(n) {\n    console.log(`step3 with ${n}`);\n    return takeLongTime(n);\n}\n```\n\n现在用 Promise 方式来实现这三个步骤的处理\n```\nfunction doIt() {\n    console.time(\"doIt\");\n    const time1 = 300;\n    step1(time1)\n        .then(time2 => step2(time2))\n        .then(time3 => step3(time3))\n        .then(result => {\n            console.log(`result is ${result}`);\n            console.timeEnd(\"doIt\");\n        });\n}\n\ndoIt();\n```\n\n用 async/await 来实现\n```\nasync function doIt() {\n    console.time(\"doIt\");\n    const time1 = 300;\n    const time2 = await step1(time1);\n    const time3 = await step2(time2);\n    const result = await step3(time3);\n    console.log(`result is ${result}`);\n    console.timeEnd(\"doIt\");\n}\n\ndoIt();\n```\n\n### 捕捉错误\n既然.then(..)不用写了，那么.catch(..)也不用写，可以直接用标准的try catch语法捕捉错误。\n```\nconst start = async function () {\n    try {\n        console.log('start');\n        await sleep(3000); // 这里得到了一个返回错误\n        \n        // 所以以下代码不会被执行了\n        console.log('end');\n    } catch (err) {\n        console.log(err); // 这里捕捉到错误 `error`\n    }\n};\n```\n\n\n","source":"_posts/async.md","raw":"---\ntitle: JavaScript 的 async/await\ndate: 2018-12-28 \ntags: ['JavaScript']\ncategories: JavaScript\n---\n\n\n\n### 什么是async、await\n<!-- more -->\n\nasync 是“异步”的简写，而 await 可以认为是 async wait 的简写。所以应该很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。\n\n### async\n1.async用法，它作为一个关键字放到函数前面，用于表示函数是一个异步函数，因为async就是异步的意思， 异步函数也就意味着该函数的执行不会阻塞后面代码的执行。 写一个async 函数\n```\nasync function test() {\n    return \"hello world\"\n}\n```\n2.语法就是在函数前面加上async关键字，用来表示它是异步的，怎么调用呢？async 函数也是函数，平时我们怎么使用函数就怎么使用它，直接加括号调用就可以了，为了表示它没有阻塞它后面代码的执行。\n```\nconsole.log(test())\n//输出的是一个Promisea对象\n\nPromise\n__proto__: Promise\n[[PromiseStatus]]: \"resolved\"\n[[PromiseValue]]: \"hell\"\n```\n\n3.async 函数返回的是一个 Promise 对象。从文档中也可以得到这个信息。async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。\n\n### await\n1.一般来说，都认为 await 是在等待一个 async 函数完成。不过按语法说明，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。\n\n2.async函数返回的是一个Promise对象，所以await可以用于等待一个async函数的返回值，await就是等待async的返回值。\n\n```\nfunction test1() {\n    reuturn \"test1\"\n}\nfunction test2() {\n    reuturn \"test2\"\n}\nasync function test() {\n    const v1 = await test1();\n    const v2 = await test2();\n}\ntest()\n```\n\n3.async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。\n\n### async/await 干了啥\n1.async会将其后的函数的返回值封装成一个Promise对象，而await会等待这个Promise完成，并将其resolve的结果返回出来。\n\n2.async/await 的优势在于处理 then 链，单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了\n```\n/**\n * 传入参数 n，表示这个函数执行的时间（毫秒）\n * 执行的结果是 n + 200，这个值将用于下一步骤\n */\nfunction takeLongTime(n) {\n    return new Promise(resolve => {\n        setTimeout(() => resolve(n + 200), n);\n    });\n}\n\nfunction step1(n) {\n    console.log(`step1 with ${n}`);\n    return takeLongTime(n);\n}\n\nfunction step2(n) {\n    console.log(`step2 with ${n}`);\n    return takeLongTime(n);\n}\n\nfunction step3(n) {\n    console.log(`step3 with ${n}`);\n    return takeLongTime(n);\n}\n```\n\n现在用 Promise 方式来实现这三个步骤的处理\n```\nfunction doIt() {\n    console.time(\"doIt\");\n    const time1 = 300;\n    step1(time1)\n        .then(time2 => step2(time2))\n        .then(time3 => step3(time3))\n        .then(result => {\n            console.log(`result is ${result}`);\n            console.timeEnd(\"doIt\");\n        });\n}\n\ndoIt();\n```\n\n用 async/await 来实现\n```\nasync function doIt() {\n    console.time(\"doIt\");\n    const time1 = 300;\n    const time2 = await step1(time1);\n    const time3 = await step2(time2);\n    const result = await step3(time3);\n    console.log(`result is ${result}`);\n    console.timeEnd(\"doIt\");\n}\n\ndoIt();\n```\n\n### 捕捉错误\n既然.then(..)不用写了，那么.catch(..)也不用写，可以直接用标准的try catch语法捕捉错误。\n```\nconst start = async function () {\n    try {\n        console.log('start');\n        await sleep(3000); // 这里得到了一个返回错误\n        \n        // 所以以下代码不会被执行了\n        console.log('end');\n    } catch (err) {\n        console.log(err); // 这里捕捉到错误 `error`\n    }\n};\n```\n\n\n","slug":"async","published":1,"updated":"2018-12-28T14:06:13.803Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuowpbrr000mja6jh80c124t","content":"<h3 id=\"什么是async、await\"><a href=\"#什么是async、await\" class=\"headerlink\" title=\"什么是async、await\"></a>什么是async、await</h3><a id=\"more\"></a>\n<p>async 是“异步”的简写，而 await 可以认为是 async wait 的简写。所以应该很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。</p>\n<h3 id=\"async\"><a href=\"#async\" class=\"headerlink\" title=\"async\"></a>async</h3><p>1.async用法，它作为一个关键字放到函数前面，用于表示函数是一个异步函数，因为async就是异步的意思， 异步函数也就意味着该函数的执行不会阻塞后面代码的执行。 写一个async 函数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async function test() &#123;</span><br><span class=\"line\">    return &quot;hello world&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>2.语法就是在函数前面加上async关键字，用来表示它是异步的，怎么调用呢？async 函数也是函数，平时我们怎么使用函数就怎么使用它，直接加括号调用就可以了，为了表示它没有阻塞它后面代码的执行。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(test())</span><br><span class=\"line\">//输出的是一个Promisea对象</span><br><span class=\"line\"></span><br><span class=\"line\">Promise</span><br><span class=\"line\">__proto__: Promise</span><br><span class=\"line\">[[PromiseStatus]]: &quot;resolved&quot;</span><br><span class=\"line\">[[PromiseValue]]: &quot;hell&quot;</span><br></pre></td></tr></table></figure></p>\n<p>3.async 函数返回的是一个 Promise 对象。从文档中也可以得到这个信息。async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。</p>\n<h3 id=\"await\"><a href=\"#await\" class=\"headerlink\" title=\"await\"></a>await</h3><p>1.一般来说，都认为 await 是在等待一个 async 函数完成。不过按语法说明，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。</p>\n<p>2.async函数返回的是一个Promise对象，所以await可以用于等待一个async函数的返回值，await就是等待async的返回值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test1() &#123;</span><br><span class=\"line\">    reuturn &quot;test1&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function test2() &#123;</span><br><span class=\"line\">    reuturn &quot;test2&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">async function test() &#123;</span><br><span class=\"line\">    const v1 = await test1();</span><br><span class=\"line\">    const v2 = await test2();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test()</span><br></pre></td></tr></table></figure>\n<p>3.async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。</p>\n<h3 id=\"async-await-干了啥\"><a href=\"#async-await-干了啥\" class=\"headerlink\" title=\"async/await 干了啥\"></a>async/await 干了啥</h3><p>1.async会将其后的函数的返回值封装成一个Promise对象，而await会等待这个Promise完成，并将其resolve的结果返回出来。</p>\n<p>2.async/await 的优势在于处理 then 链，单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 传入参数 n，表示这个函数执行的时间（毫秒）</span><br><span class=\"line\"> * 执行的结果是 n + 200，这个值将用于下一步骤</span><br><span class=\"line\"> */</span><br><span class=\"line\">function takeLongTime(n) &#123;</span><br><span class=\"line\">    return new Promise(resolve =&gt; &#123;</span><br><span class=\"line\">        setTimeout(() =&gt; resolve(n + 200), n);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function step1(n) &#123;</span><br><span class=\"line\">    console.log(`step1 with $&#123;n&#125;`);</span><br><span class=\"line\">    return takeLongTime(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function step2(n) &#123;</span><br><span class=\"line\">    console.log(`step2 with $&#123;n&#125;`);</span><br><span class=\"line\">    return takeLongTime(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function step3(n) &#123;</span><br><span class=\"line\">    console.log(`step3 with $&#123;n&#125;`);</span><br><span class=\"line\">    return takeLongTime(n);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在用 Promise 方式来实现这三个步骤的处理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function doIt() &#123;</span><br><span class=\"line\">    console.time(&quot;doIt&quot;);</span><br><span class=\"line\">    const time1 = 300;</span><br><span class=\"line\">    step1(time1)</span><br><span class=\"line\">        .then(time2 =&gt; step2(time2))</span><br><span class=\"line\">        .then(time3 =&gt; step3(time3))</span><br><span class=\"line\">        .then(result =&gt; &#123;</span><br><span class=\"line\">            console.log(`result is $&#123;result&#125;`);</span><br><span class=\"line\">            console.timeEnd(&quot;doIt&quot;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">doIt();</span><br></pre></td></tr></table></figure></p>\n<p>用 async/await 来实现<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async function doIt() &#123;</span><br><span class=\"line\">    console.time(&quot;doIt&quot;);</span><br><span class=\"line\">    const time1 = 300;</span><br><span class=\"line\">    const time2 = await step1(time1);</span><br><span class=\"line\">    const time3 = await step2(time2);</span><br><span class=\"line\">    const result = await step3(time3);</span><br><span class=\"line\">    console.log(`result is $&#123;result&#125;`);</span><br><span class=\"line\">    console.timeEnd(&quot;doIt&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">doIt();</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"捕捉错误\"><a href=\"#捕捉错误\" class=\"headerlink\" title=\"捕捉错误\"></a>捕捉错误</h3><p>既然.then(..)不用写了，那么.catch(..)也不用写，可以直接用标准的try catch语法捕捉错误。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const start = async function () &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        console.log(&apos;start&apos;);</span><br><span class=\"line\">        await sleep(3000); // 这里得到了一个返回错误</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 所以以下代码不会被执行了</span><br><span class=\"line\">        console.log(&apos;end&apos;);</span><br><span class=\"line\">    &#125; catch (err) &#123;</span><br><span class=\"line\">        console.log(err); // 这里捕捉到错误 `error`</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"什么是async、await\"><a href=\"#什么是async、await\" class=\"headerlink\" title=\"什么是async、await\"></a>什么是async、await</h3>","more":"<p>async 是“异步”的简写，而 await 可以认为是 async wait 的简写。所以应该很好理解 async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。</p>\n<h3 id=\"async\"><a href=\"#async\" class=\"headerlink\" title=\"async\"></a>async</h3><p>1.async用法，它作为一个关键字放到函数前面，用于表示函数是一个异步函数，因为async就是异步的意思， 异步函数也就意味着该函数的执行不会阻塞后面代码的执行。 写一个async 函数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async function test() &#123;</span><br><span class=\"line\">    return &quot;hello world&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>2.语法就是在函数前面加上async关键字，用来表示它是异步的，怎么调用呢？async 函数也是函数，平时我们怎么使用函数就怎么使用它，直接加括号调用就可以了，为了表示它没有阻塞它后面代码的执行。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(test())</span><br><span class=\"line\">//输出的是一个Promisea对象</span><br><span class=\"line\"></span><br><span class=\"line\">Promise</span><br><span class=\"line\">__proto__: Promise</span><br><span class=\"line\">[[PromiseStatus]]: &quot;resolved&quot;</span><br><span class=\"line\">[[PromiseValue]]: &quot;hell&quot;</span><br></pre></td></tr></table></figure></p>\n<p>3.async 函数返回的是一个 Promise 对象。从文档中也可以得到这个信息。async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。</p>\n<h3 id=\"await\"><a href=\"#await\" class=\"headerlink\" title=\"await\"></a>await</h3><p>1.一般来说，都认为 await 是在等待一个 async 函数完成。不过按语法说明，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。</p>\n<p>2.async函数返回的是一个Promise对象，所以await可以用于等待一个async函数的返回值，await就是等待async的返回值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function test1() &#123;</span><br><span class=\"line\">    reuturn &quot;test1&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function test2() &#123;</span><br><span class=\"line\">    reuturn &quot;test2&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">async function test() &#123;</span><br><span class=\"line\">    const v1 = await test1();</span><br><span class=\"line\">    const v2 = await test2();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">test()</span><br></pre></td></tr></table></figure>\n<p>3.async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。</p>\n<h3 id=\"async-await-干了啥\"><a href=\"#async-await-干了啥\" class=\"headerlink\" title=\"async/await 干了啥\"></a>async/await 干了啥</h3><p>1.async会将其后的函数的返回值封装成一个Promise对象，而await会等待这个Promise完成，并将其resolve的结果返回出来。</p>\n<p>2.async/await 的优势在于处理 then 链，单一的 Promise 链并不能发现 async/await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/**</span><br><span class=\"line\"> * 传入参数 n，表示这个函数执行的时间（毫秒）</span><br><span class=\"line\"> * 执行的结果是 n + 200，这个值将用于下一步骤</span><br><span class=\"line\"> */</span><br><span class=\"line\">function takeLongTime(n) &#123;</span><br><span class=\"line\">    return new Promise(resolve =&gt; &#123;</span><br><span class=\"line\">        setTimeout(() =&gt; resolve(n + 200), n);</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function step1(n) &#123;</span><br><span class=\"line\">    console.log(`step1 with $&#123;n&#125;`);</span><br><span class=\"line\">    return takeLongTime(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function step2(n) &#123;</span><br><span class=\"line\">    console.log(`step2 with $&#123;n&#125;`);</span><br><span class=\"line\">    return takeLongTime(n);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function step3(n) &#123;</span><br><span class=\"line\">    console.log(`step3 with $&#123;n&#125;`);</span><br><span class=\"line\">    return takeLongTime(n);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>现在用 Promise 方式来实现这三个步骤的处理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function doIt() &#123;</span><br><span class=\"line\">    console.time(&quot;doIt&quot;);</span><br><span class=\"line\">    const time1 = 300;</span><br><span class=\"line\">    step1(time1)</span><br><span class=\"line\">        .then(time2 =&gt; step2(time2))</span><br><span class=\"line\">        .then(time3 =&gt; step3(time3))</span><br><span class=\"line\">        .then(result =&gt; &#123;</span><br><span class=\"line\">            console.log(`result is $&#123;result&#125;`);</span><br><span class=\"line\">            console.timeEnd(&quot;doIt&quot;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">doIt();</span><br></pre></td></tr></table></figure></p>\n<p>用 async/await 来实现<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async function doIt() &#123;</span><br><span class=\"line\">    console.time(&quot;doIt&quot;);</span><br><span class=\"line\">    const time1 = 300;</span><br><span class=\"line\">    const time2 = await step1(time1);</span><br><span class=\"line\">    const time3 = await step2(time2);</span><br><span class=\"line\">    const result = await step3(time3);</span><br><span class=\"line\">    console.log(`result is $&#123;result&#125;`);</span><br><span class=\"line\">    console.timeEnd(&quot;doIt&quot;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">doIt();</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"捕捉错误\"><a href=\"#捕捉错误\" class=\"headerlink\" title=\"捕捉错误\"></a>捕捉错误</h3><p>既然.then(..)不用写了，那么.catch(..)也不用写，可以直接用标准的try catch语法捕捉错误。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const start = async function () &#123;</span><br><span class=\"line\">    try &#123;</span><br><span class=\"line\">        console.log(&apos;start&apos;);</span><br><span class=\"line\">        await sleep(3000); // 这里得到了一个返回错误</span><br><span class=\"line\">        </span><br><span class=\"line\">        // 所以以下代码不会被执行了</span><br><span class=\"line\">        console.log(&apos;end&apos;);</span><br><span class=\"line\">    &#125; catch (err) &#123;</span><br><span class=\"line\">        console.log(err); // 这里捕捉到错误 `error`</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure></p>"},{"title":"axios","date":"2019-04-17T12:32:49.000Z","_content":"\n### axios封装\n<!-- more -->\n\n```\nrequest.js\n\nimport _axios from 'axios';\nimport qs from  'qs';\n\n//新建一个 axios 实例\nconst axios = _axios.create({\n    //当在开发模式下,baseURL等于null,使用本地的localhost,设置本地代理解决跨域\n    baseURL:process.env.NODE_ENV=='development'?null:'http://xxx.xx.xx:8080/',\n    transformRequest:[function(data){       \n        data = qs.stringify(data);\n        return data\n    }],\n    headers:{\n        'Content-Type': 'application/x-www-form-urlencoded'\n    },\n    transformResponse: [function (data) {\n        // 对 data 进行任意转换处理\n        let _data = JSON.parse(data);\n        return _data;\n    }],\n    withCredentials:true,  // 表示跨域请求时是否需要使用凭证\n    timeout: 5000,  // 如果请求话费了超过 `timeout` 的时间，请求将被中断\n})\naxios.defaults.withCredentials = true\n\n// 添加请求拦截器\naxios.interceptors.request.use(\n    config => {  \n        //在发送请求之前做些什么\n        // if (token) {\n        //     config.headers['X-Token'] = getToken()\n        // }\n        return config\n    },\n    error => {\n        // 对请求错误做些什么\n        console.log('err' + error) // for debug\n        return Promise.reject(error)\n    }\n)\n\n// 添加响应拦截器\naxios.interceptors.response.use(\n  response => {\n    //对响应数据做点什么\n    const res = response.data\n    //如果自定义代码不是20000，则被判断为错误。统一处理接口报错\n    if (res.code !== 20000) {\n      return Promise.reject(res.message || 'error')\n    } else {\n      return response\n    }\n  },\n  error => {\n    //对响应错误做点什么\n    console.log('err' + error) // for debug\n    return Promise.reject(error)\n  }\n)\nexport default axios;\n```\n\n```\n//api.js\n\nimport http from request.js\n\n//get\n\nexport const getGet = ({id}) => {\n    let params = { ID }\n    return http.get('url',params)\n}\n\n//post\nexport const getPost = ({id}) => {\n    let data = { ID }\n    return http.post('url',data)\n}\n```\n","source":"_posts/axios.md","raw":"---\ntitle: axios\ndate: 2019-04-17 20:32:49\ntags: [\"vue\"]\ncategories: vue\n---\n\n### axios封装\n<!-- more -->\n\n```\nrequest.js\n\nimport _axios from 'axios';\nimport qs from  'qs';\n\n//新建一个 axios 实例\nconst axios = _axios.create({\n    //当在开发模式下,baseURL等于null,使用本地的localhost,设置本地代理解决跨域\n    baseURL:process.env.NODE_ENV=='development'?null:'http://xxx.xx.xx:8080/',\n    transformRequest:[function(data){       \n        data = qs.stringify(data);\n        return data\n    }],\n    headers:{\n        'Content-Type': 'application/x-www-form-urlencoded'\n    },\n    transformResponse: [function (data) {\n        // 对 data 进行任意转换处理\n        let _data = JSON.parse(data);\n        return _data;\n    }],\n    withCredentials:true,  // 表示跨域请求时是否需要使用凭证\n    timeout: 5000,  // 如果请求话费了超过 `timeout` 的时间，请求将被中断\n})\naxios.defaults.withCredentials = true\n\n// 添加请求拦截器\naxios.interceptors.request.use(\n    config => {  \n        //在发送请求之前做些什么\n        // if (token) {\n        //     config.headers['X-Token'] = getToken()\n        // }\n        return config\n    },\n    error => {\n        // 对请求错误做些什么\n        console.log('err' + error) // for debug\n        return Promise.reject(error)\n    }\n)\n\n// 添加响应拦截器\naxios.interceptors.response.use(\n  response => {\n    //对响应数据做点什么\n    const res = response.data\n    //如果自定义代码不是20000，则被判断为错误。统一处理接口报错\n    if (res.code !== 20000) {\n      return Promise.reject(res.message || 'error')\n    } else {\n      return response\n    }\n  },\n  error => {\n    //对响应错误做点什么\n    console.log('err' + error) // for debug\n    return Promise.reject(error)\n  }\n)\nexport default axios;\n```\n\n```\n//api.js\n\nimport http from request.js\n\n//get\n\nexport const getGet = ({id}) => {\n    let params = { ID }\n    return http.get('url',params)\n}\n\n//post\nexport const getPost = ({id}) => {\n    let data = { ID }\n    return http.post('url',data)\n}\n```\n","slug":"axios","published":1,"updated":"2019-04-17T14:36:45.709Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuowpbru000rja6jf9zi0qgi","content":"<h3 id=\"axios封装\"><a href=\"#axios封装\" class=\"headerlink\" title=\"axios封装\"></a>axios封装</h3><a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request.js</span><br><span class=\"line\"></span><br><span class=\"line\">import _axios from &apos;axios&apos;;</span><br><span class=\"line\">import qs from  &apos;qs&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">//新建一个 axios 实例</span><br><span class=\"line\">const axios = _axios.create(&#123;</span><br><span class=\"line\">    //当在开发模式下,baseURL等于null,使用本地的localhost,设置本地代理解决跨域</span><br><span class=\"line\">    baseURL:process.env.NODE_ENV==&apos;development&apos;?null:&apos;http://xxx.xx.xx:8080/&apos;,</span><br><span class=\"line\">    transformRequest:[function(data)&#123;       </span><br><span class=\"line\">        data = qs.stringify(data);</span><br><span class=\"line\">        return data</span><br><span class=\"line\">    &#125;],</span><br><span class=\"line\">    headers:&#123;</span><br><span class=\"line\">        &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    transformResponse: [function (data) &#123;</span><br><span class=\"line\">        // 对 data 进行任意转换处理</span><br><span class=\"line\">        let _data = JSON.parse(data);</span><br><span class=\"line\">        return _data;</span><br><span class=\"line\">    &#125;],</span><br><span class=\"line\">    withCredentials:true,  // 表示跨域请求时是否需要使用凭证</span><br><span class=\"line\">    timeout: 5000,  // 如果请求话费了超过 `timeout` 的时间，请求将被中断</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">axios.defaults.withCredentials = true</span><br><span class=\"line\"></span><br><span class=\"line\">// 添加请求拦截器</span><br><span class=\"line\">axios.interceptors.request.use(</span><br><span class=\"line\">    config =&gt; &#123;  </span><br><span class=\"line\">        //在发送请求之前做些什么</span><br><span class=\"line\">        // if (token) &#123;</span><br><span class=\"line\">        //     config.headers[&apos;X-Token&apos;] = getToken()</span><br><span class=\"line\">        // &#125;</span><br><span class=\"line\">        return config</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    error =&gt; &#123;</span><br><span class=\"line\">        // 对请求错误做些什么</span><br><span class=\"line\">        console.log(&apos;err&apos; + error) // for debug</span><br><span class=\"line\">        return Promise.reject(error)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">// 添加响应拦截器</span><br><span class=\"line\">axios.interceptors.response.use(</span><br><span class=\"line\">  response =&gt; &#123;</span><br><span class=\"line\">    //对响应数据做点什么</span><br><span class=\"line\">    const res = response.data</span><br><span class=\"line\">    //如果自定义代码不是20000，则被判断为错误。统一处理接口报错</span><br><span class=\"line\">    if (res.code !== 20000) &#123;</span><br><span class=\"line\">      return Promise.reject(res.message || &apos;error&apos;)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      return response</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  error =&gt; &#123;</span><br><span class=\"line\">    //对响应错误做点什么</span><br><span class=\"line\">    console.log(&apos;err&apos; + error) // for debug</span><br><span class=\"line\">    return Promise.reject(error)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\">export default axios;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//api.js</span><br><span class=\"line\"></span><br><span class=\"line\">import http from request.js</span><br><span class=\"line\"></span><br><span class=\"line\">//get</span><br><span class=\"line\"></span><br><span class=\"line\">export const getGet = (&#123;id&#125;) =&gt; &#123;</span><br><span class=\"line\">    let params = &#123; ID &#125;</span><br><span class=\"line\">    return http.get(&apos;url&apos;,params)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//post</span><br><span class=\"line\">export const getPost = (&#123;id&#125;) =&gt; &#123;</span><br><span class=\"line\">    let data = &#123; ID &#125;</span><br><span class=\"line\">    return http.post(&apos;url&apos;,data)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"axios封装\"><a href=\"#axios封装\" class=\"headerlink\" title=\"axios封装\"></a>axios封装</h3>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">request.js</span><br><span class=\"line\"></span><br><span class=\"line\">import _axios from &apos;axios&apos;;</span><br><span class=\"line\">import qs from  &apos;qs&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">//新建一个 axios 实例</span><br><span class=\"line\">const axios = _axios.create(&#123;</span><br><span class=\"line\">    //当在开发模式下,baseURL等于null,使用本地的localhost,设置本地代理解决跨域</span><br><span class=\"line\">    baseURL:process.env.NODE_ENV==&apos;development&apos;?null:&apos;http://xxx.xx.xx:8080/&apos;,</span><br><span class=\"line\">    transformRequest:[function(data)&#123;       </span><br><span class=\"line\">        data = qs.stringify(data);</span><br><span class=\"line\">        return data</span><br><span class=\"line\">    &#125;],</span><br><span class=\"line\">    headers:&#123;</span><br><span class=\"line\">        &apos;Content-Type&apos;: &apos;application/x-www-form-urlencoded&apos;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    transformResponse: [function (data) &#123;</span><br><span class=\"line\">        // 对 data 进行任意转换处理</span><br><span class=\"line\">        let _data = JSON.parse(data);</span><br><span class=\"line\">        return _data;</span><br><span class=\"line\">    &#125;],</span><br><span class=\"line\">    withCredentials:true,  // 表示跨域请求时是否需要使用凭证</span><br><span class=\"line\">    timeout: 5000,  // 如果请求话费了超过 `timeout` 的时间，请求将被中断</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">axios.defaults.withCredentials = true</span><br><span class=\"line\"></span><br><span class=\"line\">// 添加请求拦截器</span><br><span class=\"line\">axios.interceptors.request.use(</span><br><span class=\"line\">    config =&gt; &#123;  </span><br><span class=\"line\">        //在发送请求之前做些什么</span><br><span class=\"line\">        // if (token) &#123;</span><br><span class=\"line\">        //     config.headers[&apos;X-Token&apos;] = getToken()</span><br><span class=\"line\">        // &#125;</span><br><span class=\"line\">        return config</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    error =&gt; &#123;</span><br><span class=\"line\">        // 对请求错误做些什么</span><br><span class=\"line\">        console.log(&apos;err&apos; + error) // for debug</span><br><span class=\"line\">        return Promise.reject(error)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">// 添加响应拦截器</span><br><span class=\"line\">axios.interceptors.response.use(</span><br><span class=\"line\">  response =&gt; &#123;</span><br><span class=\"line\">    //对响应数据做点什么</span><br><span class=\"line\">    const res = response.data</span><br><span class=\"line\">    //如果自定义代码不是20000，则被判断为错误。统一处理接口报错</span><br><span class=\"line\">    if (res.code !== 20000) &#123;</span><br><span class=\"line\">      return Promise.reject(res.message || &apos;error&apos;)</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">      return response</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  error =&gt; &#123;</span><br><span class=\"line\">    //对响应错误做点什么</span><br><span class=\"line\">    console.log(&apos;err&apos; + error) // for debug</span><br><span class=\"line\">    return Promise.reject(error)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">)</span><br><span class=\"line\">export default axios;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//api.js</span><br><span class=\"line\"></span><br><span class=\"line\">import http from request.js</span><br><span class=\"line\"></span><br><span class=\"line\">//get</span><br><span class=\"line\"></span><br><span class=\"line\">export const getGet = (&#123;id&#125;) =&gt; &#123;</span><br><span class=\"line\">    let params = &#123; ID &#125;</span><br><span class=\"line\">    return http.get(&apos;url&apos;,params)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//post</span><br><span class=\"line\">export const getPost = (&#123;id&#125;) =&gt; &#123;</span><br><span class=\"line\">    let data = &#123; ID &#125;</span><br><span class=\"line\">    return http.post(&apos;url&apos;,data)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"为什么写博客","date":"2018-09-28T13:08:24.000Z","_content":"\n### 为什么坚持写博客?\n<!--more-->\n> 原因\n\n    这个博客是由我自己一点点去搭建的，其中也遇到了不少麻烦，特别是在域名解析部分。\n\n    为什么要去搭建一个博客呢？可以看看自己的轨迹，做过什么，不忘处心，不遗失自己。\n\n    之前一直有想在博客园去写博客，但发现自己写不出东西来～～～，总之就是下不了笔。\n\n    我自己搭建的博客就是想把自己对前端或其它领域某些知识点自己思考写出来，积累下来。\n    \n    有很多事情你以为你知道，其实你什么都不知道。\n\n> 我的理解\n\n    未来自己写博客的过程中，对某个知识点进行比较全的解析，怎么来的？用在哪里？了解其原理。\n\n    用心去写，希望在多年以后回过头来看，原来曾经自己写得这么“傻逼”。\n\n    这是第一篇文章，以后慢慢来写，因为菜，所以好好学习、天天向上。\n\n    下一篇想写个人博客的搭建！\n","source":"_posts/blog-start.md","raw":"---\ntitle: 为什么写博客\ndate: 2018-09-28 21:08:24\ntags: ['随笔']\ncategories: 随笔\n---\n\n### 为什么坚持写博客?\n<!--more-->\n> 原因\n\n    这个博客是由我自己一点点去搭建的，其中也遇到了不少麻烦，特别是在域名解析部分。\n\n    为什么要去搭建一个博客呢？可以看看自己的轨迹，做过什么，不忘处心，不遗失自己。\n\n    之前一直有想在博客园去写博客，但发现自己写不出东西来～～～，总之就是下不了笔。\n\n    我自己搭建的博客就是想把自己对前端或其它领域某些知识点自己思考写出来，积累下来。\n    \n    有很多事情你以为你知道，其实你什么都不知道。\n\n> 我的理解\n\n    未来自己写博客的过程中，对某个知识点进行比较全的解析，怎么来的？用在哪里？了解其原理。\n\n    用心去写，希望在多年以后回过头来看，原来曾经自己写得这么“傻逼”。\n\n    这是第一篇文章，以后慢慢来写，因为菜，所以好好学习、天天向上。\n\n    下一篇想写个人博客的搭建！\n","slug":"blog-start","published":1,"updated":"2018-09-28T13:36:54.089Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuowpbrw000uja6j28m6w8ro","content":"<h3 id=\"为什么坚持写博客\"><a href=\"#为什么坚持写博客\" class=\"headerlink\" title=\"为什么坚持写博客?\"></a>为什么坚持写博客?</h3><a id=\"more\"></a>\n<blockquote>\n<p>原因</p>\n</blockquote>\n<pre><code>这个博客是由我自己一点点去搭建的，其中也遇到了不少麻烦，特别是在域名解析部分。\n\n为什么要去搭建一个博客呢？可以看看自己的轨迹，做过什么，不忘处心，不遗失自己。\n\n之前一直有想在博客园去写博客，但发现自己写不出东西来～～～，总之就是下不了笔。\n\n我自己搭建的博客就是想把自己对前端或其它领域某些知识点自己思考写出来，积累下来。\n\n有很多事情你以为你知道，其实你什么都不知道。\n</code></pre><blockquote>\n<p>我的理解</p>\n</blockquote>\n<pre><code>未来自己写博客的过程中，对某个知识点进行比较全的解析，怎么来的？用在哪里？了解其原理。\n\n用心去写，希望在多年以后回过头来看，原来曾经自己写得这么“傻逼”。\n\n这是第一篇文章，以后慢慢来写，因为菜，所以好好学习、天天向上。\n\n下一篇想写个人博客的搭建！\n</code></pre>","site":{"data":{}},"excerpt":"<h3 id=\"为什么坚持写博客\"><a href=\"#为什么坚持写博客\" class=\"headerlink\" title=\"为什么坚持写博客?\"></a>为什么坚持写博客?</h3>","more":"<blockquote>\n<p>原因</p>\n</blockquote>\n<pre><code>这个博客是由我自己一点点去搭建的，其中也遇到了不少麻烦，特别是在域名解析部分。\n\n为什么要去搭建一个博客呢？可以看看自己的轨迹，做过什么，不忘处心，不遗失自己。\n\n之前一直有想在博客园去写博客，但发现自己写不出东西来～～～，总之就是下不了笔。\n\n我自己搭建的博客就是想把自己对前端或其它领域某些知识点自己思考写出来，积累下来。\n\n有很多事情你以为你知道，其实你什么都不知道。\n</code></pre><blockquote>\n<p>我的理解</p>\n</blockquote>\n<pre><code>未来自己写博客的过程中，对某个知识点进行比较全的解析，怎么来的？用在哪里？了解其原理。\n\n用心去写，希望在多年以后回过头来看，原来曾经自己写得这么“傻逼”。\n\n这是第一篇文章，以后慢慢来写，因为菜，所以好好学习、天天向上。\n\n下一篇想写个人博客的搭建！\n</code></pre>"},{"title":"搭建个人博客","date":"2018-09-30T13:45:40.000Z","_content":"\n### hexo + github 搭建属于自己的个人博客\n<!-- more -->\n\n### 准备工作\n\n1.[node](https://nodejs.org/zh-cn/)：安装node，到官网下载，一路安装即可，在命令行输入node -v，出现版本号安装成功。\n\n2.[git](https://git-scm.com/)：一路安装即可，[教程](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000)\n\n3.[github](https://github.com/)：程序员的交流网站，用来做博客的远程创库、域名、服务器。\n\n(Mac系统下载Homebrew，直接在终端进行下载，brew install git、brew install node)\n\n### 安装hexo框架\n\n``` bash\nnpm install -g hexo\n```\n\n### 初始化项目\n终端cd到一个选定的目录文件下(如新建一个文件夹blog)\n``` bash\nhexo init\n```\n查看blog文件下是否存在node_modules文件夹,不在则执行如下命令\n``` bash\nhexo install\n```\n开启hexo服务器，在浏览器打开网址http://localhost:4000，出现hexo页面\n```bash\nhexo s\n```\n\n### 创建github仓库\n\n1.打开github，注册账号，需要和电脑关联，在本地创建ssh key，可在百度输入github与本地电脑关联\n\n2.创建github仓库,点击+号(New repository),新建仓库，名为用户名.github.io固定写法。(用户名就是自己github的名字)\n\n3.Create repository创建仓库，其它不用选择\n\n4.cd到blog文件夹，打开配置文件_config.yml\n```bash\ndeploy:\n    type: git\n    repository: https://github.com/xxx/xxx.github.io.git\n    branch: master\n```\n你需要将repository后xxx换成你自己的用户名,浏览器输入xxx.github.io\n\n### 发布文章\ncd到blog文件夹，执行如下命令新建文章\n```bash\nhexo new \"postName\"\n```\n名为postName的文件夹在/blog/source/_posts下。\n\n编辑文章完成，终端cd到blog文件夹下，执行如下命令\n```bash\nhexo g\n```\n```bash\nhexo d\n```\n\n### 安装theme\n可以去搜索关于hexo的主题页，修饰自己的个人网站,在github上Clone or download地址\n终端cd到blog的目录下执行如下命令\n```bash\ngit clone https://github.com/iissnan/hexo-theme-next themes/next\n```\ncd到blog文件夹(每次部署文章的步骤)\n```bash\nhexo clean\n```\n```bash\nhexo g\n```\n```bash\nhexo d\n```\n至于更改theme内容，配置主题的网站，去修改blog/_config.yml文件和blog/themes/next/_config.yml，不要忘记冒号：加空格\n\n### 绑定个人域名\n1.想让自己的网站看起来更有个性，可以去万网购买喜欢的域名~~\n\n2.购买域名后，需要进行域名解析，之前先进行域名的实名验证，填写好信息，万网有详细的教程\n\n3.在blog/source建立CNAME的文件，没有后缀名，内容输入购买的域名，如www.xxx.com\n\n4.在万网对域名进行解析，进入解析设置，点击添加记录，需要添加4条记录\n```bash\n第一条记录：\n记录类型：A\n主机记录:www\n解析线路：默认\n记录值192.30.252.154\n```\n```\n第二条记录：\n记录类型：A\n主机记录:@\n解析线路：默认\n记录值192.30.252.154\n```\n```\n第三条记录：\n记录类型：A\n主机记录:www\n解析线路：默认\n记录值192.30.252.153\n```\n```\n第四条记录：\n记录类型：A\n主机记录:@\n解析线路：默认\n记录值192.30.252.153\n```\n\n### 总结和说明\nhexo + github搭建个人网站非常简单，主要在域名解析部分，当时各种解析添加记录都无法进行解析，这4条记录一定得添加好，绑定属于自己的域名。\n搭建属于自己的个人网站成就感满满，也希望自己一直坚持写博客，把自己遇到的问题和所做的收获一点一滴记录起来。明天是国庆节，国庆节快乐！！！\n\n\n\n\n\n\n\n\n    \n","source":"_posts/blog-construct.md","raw":"---\ntitle: 搭建个人博客\ndate: 2018-09-30 21:45:40\ntags: ['github']\ncategories: 随笔\n---\n\n### hexo + github 搭建属于自己的个人博客\n<!-- more -->\n\n### 准备工作\n\n1.[node](https://nodejs.org/zh-cn/)：安装node，到官网下载，一路安装即可，在命令行输入node -v，出现版本号安装成功。\n\n2.[git](https://git-scm.com/)：一路安装即可，[教程](https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000)\n\n3.[github](https://github.com/)：程序员的交流网站，用来做博客的远程创库、域名、服务器。\n\n(Mac系统下载Homebrew，直接在终端进行下载，brew install git、brew install node)\n\n### 安装hexo框架\n\n``` bash\nnpm install -g hexo\n```\n\n### 初始化项目\n终端cd到一个选定的目录文件下(如新建一个文件夹blog)\n``` bash\nhexo init\n```\n查看blog文件下是否存在node_modules文件夹,不在则执行如下命令\n``` bash\nhexo install\n```\n开启hexo服务器，在浏览器打开网址http://localhost:4000，出现hexo页面\n```bash\nhexo s\n```\n\n### 创建github仓库\n\n1.打开github，注册账号，需要和电脑关联，在本地创建ssh key，可在百度输入github与本地电脑关联\n\n2.创建github仓库,点击+号(New repository),新建仓库，名为用户名.github.io固定写法。(用户名就是自己github的名字)\n\n3.Create repository创建仓库，其它不用选择\n\n4.cd到blog文件夹，打开配置文件_config.yml\n```bash\ndeploy:\n    type: git\n    repository: https://github.com/xxx/xxx.github.io.git\n    branch: master\n```\n你需要将repository后xxx换成你自己的用户名,浏览器输入xxx.github.io\n\n### 发布文章\ncd到blog文件夹，执行如下命令新建文章\n```bash\nhexo new \"postName\"\n```\n名为postName的文件夹在/blog/source/_posts下。\n\n编辑文章完成，终端cd到blog文件夹下，执行如下命令\n```bash\nhexo g\n```\n```bash\nhexo d\n```\n\n### 安装theme\n可以去搜索关于hexo的主题页，修饰自己的个人网站,在github上Clone or download地址\n终端cd到blog的目录下执行如下命令\n```bash\ngit clone https://github.com/iissnan/hexo-theme-next themes/next\n```\ncd到blog文件夹(每次部署文章的步骤)\n```bash\nhexo clean\n```\n```bash\nhexo g\n```\n```bash\nhexo d\n```\n至于更改theme内容，配置主题的网站，去修改blog/_config.yml文件和blog/themes/next/_config.yml，不要忘记冒号：加空格\n\n### 绑定个人域名\n1.想让自己的网站看起来更有个性，可以去万网购买喜欢的域名~~\n\n2.购买域名后，需要进行域名解析，之前先进行域名的实名验证，填写好信息，万网有详细的教程\n\n3.在blog/source建立CNAME的文件，没有后缀名，内容输入购买的域名，如www.xxx.com\n\n4.在万网对域名进行解析，进入解析设置，点击添加记录，需要添加4条记录\n```bash\n第一条记录：\n记录类型：A\n主机记录:www\n解析线路：默认\n记录值192.30.252.154\n```\n```\n第二条记录：\n记录类型：A\n主机记录:@\n解析线路：默认\n记录值192.30.252.154\n```\n```\n第三条记录：\n记录类型：A\n主机记录:www\n解析线路：默认\n记录值192.30.252.153\n```\n```\n第四条记录：\n记录类型：A\n主机记录:@\n解析线路：默认\n记录值192.30.252.153\n```\n\n### 总结和说明\nhexo + github搭建个人网站非常简单，主要在域名解析部分，当时各种解析添加记录都无法进行解析，这4条记录一定得添加好，绑定属于自己的域名。\n搭建属于自己的个人网站成就感满满，也希望自己一直坚持写博客，把自己遇到的问题和所做的收获一点一滴记录起来。明天是国庆节，国庆节快乐！！！\n\n\n\n\n\n\n\n\n    \n","slug":"blog-construct","published":1,"updated":"2018-09-30T14:53:31.805Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuowpbry000zja6ji09yn0xq","content":"<h3 id=\"hexo-github-搭建属于自己的个人博客\"><a href=\"#hexo-github-搭建属于自己的个人博客\" class=\"headerlink\" title=\"hexo + github 搭建属于自己的个人博客\"></a>hexo + github 搭建属于自己的个人博客</h3><a id=\"more\"></a>\n<h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><p>1.<a href=\"https://nodejs.org/zh-cn/\" target=\"_blank\" rel=\"noopener\">node</a>：安装node，到官网下载，一路安装即可，在命令行输入node -v，出现版本号安装成功。</p>\n<p>2.<a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"noopener\">git</a>：一路安装即可，<a href=\"https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\" target=\"_blank\" rel=\"noopener\">教程</a></p>\n<p>3.<a href=\"https://github.com/\" target=\"_blank\" rel=\"noopener\">github</a>：程序员的交流网站，用来做博客的远程创库、域名、服务器。</p>\n<p>(Mac系统下载Homebrew，直接在终端进行下载，brew install git、brew install node)</p>\n<h3 id=\"安装hexo框架\"><a href=\"#安装hexo框架\" class=\"headerlink\" title=\"安装hexo框架\"></a>安装hexo框架</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo</span><br></pre></td></tr></table></figure>\n<h3 id=\"初始化项目\"><a href=\"#初始化项目\" class=\"headerlink\" title=\"初始化项目\"></a>初始化项目</h3><p>终端cd到一个选定的目录文件下(如新建一个文件夹blog)<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init</span><br></pre></td></tr></table></figure></p>\n<p>查看blog文件下是否存在node_modules文件夹,不在则执行如下命令<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo install</span><br></pre></td></tr></table></figure></p>\n<p>开启hexo服务器，在浏览器打开网址<a href=\"http://localhost:4000，出现hexo页面\" target=\"_blank\" rel=\"noopener\">http://localhost:4000，出现hexo页面</a><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"创建github仓库\"><a href=\"#创建github仓库\" class=\"headerlink\" title=\"创建github仓库\"></a>创建github仓库</h3><p>1.打开github，注册账号，需要和电脑关联，在本地创建ssh key，可在百度输入github与本地电脑关联</p>\n<p>2.创建github仓库,点击+号(New repository),新建仓库，名为用户名.github.io固定写法。(用户名就是自己github的名字)</p>\n<p>3.Create repository创建仓库，其它不用选择</p>\n<p>4.cd到blog文件夹，打开配置文件_config.yml<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">    <span class=\"built_in\">type</span>: git</span><br><span class=\"line\">    repository: https://github.com/xxx/xxx.github.io.git</span><br><span class=\"line\">    branch: master</span><br></pre></td></tr></table></figure></p>\n<p>你需要将repository后xxx换成你自己的用户名,浏览器输入xxx.github.io</p>\n<h3 id=\"发布文章\"><a href=\"#发布文章\" class=\"headerlink\" title=\"发布文章\"></a>发布文章</h3><p>cd到blog文件夹，执行如下命令新建文章<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new <span class=\"string\">\"postName\"</span></span><br></pre></td></tr></table></figure></p>\n<p>名为postName的文件夹在/blog/source/_posts下。</p>\n<p>编辑文章完成，终端cd到blog文件夹下，执行如下命令<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n<h3 id=\"安装theme\"><a href=\"#安装theme\" class=\"headerlink\" title=\"安装theme\"></a>安装theme</h3><p>可以去搜索关于hexo的主题页，修饰自己的个人网站,在github上Clone or download地址<br>终端cd到blog的目录下执行如下命令<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></p>\n<p>cd到blog文件夹(每次部署文章的步骤)<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n<p>至于更改theme内容，配置主题的网站，去修改blog/_config.yml文件和blog/themes/next/_config.yml，不要忘记冒号：加空格</p>\n<h3 id=\"绑定个人域名\"><a href=\"#绑定个人域名\" class=\"headerlink\" title=\"绑定个人域名\"></a>绑定个人域名</h3><p>1.想让自己的网站看起来更有个性，可以去万网购买喜欢的域名~~</p>\n<p>2.购买域名后，需要进行域名解析，之前先进行域名的实名验证，填写好信息，万网有详细的教程</p>\n<p>3.在blog/source建立CNAME的文件，没有后缀名，内容输入购买的域名，如<a href=\"http://www.xxx.com\" target=\"_blank\" rel=\"noopener\">www.xxx.com</a></p>\n<p>4.在万网对域名进行解析，进入解析设置，点击添加记录，需要添加4条记录<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一条记录：</span><br><span class=\"line\">记录类型：A</span><br><span class=\"line\">主机记录:www</span><br><span class=\"line\">解析线路：默认</span><br><span class=\"line\">记录值192.30.252.154</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第二条记录：</span><br><span class=\"line\">记录类型：A</span><br><span class=\"line\">主机记录:@</span><br><span class=\"line\">解析线路：默认</span><br><span class=\"line\">记录值192.30.252.154</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第三条记录：</span><br><span class=\"line\">记录类型：A</span><br><span class=\"line\">主机记录:www</span><br><span class=\"line\">解析线路：默认</span><br><span class=\"line\">记录值192.30.252.153</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第四条记录：</span><br><span class=\"line\">记录类型：A</span><br><span class=\"line\">主机记录:@</span><br><span class=\"line\">解析线路：默认</span><br><span class=\"line\">记录值192.30.252.153</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结和说明\"><a href=\"#总结和说明\" class=\"headerlink\" title=\"总结和说明\"></a>总结和说明</h3><p>hexo + github搭建个人网站非常简单，主要在域名解析部分，当时各种解析添加记录都无法进行解析，这4条记录一定得添加好，绑定属于自己的域名。<br>搭建属于自己的个人网站成就感满满，也希望自己一直坚持写博客，把自己遇到的问题和所做的收获一点一滴记录起来。明天是国庆节，国庆节快乐！！！</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"hexo-github-搭建属于自己的个人博客\"><a href=\"#hexo-github-搭建属于自己的个人博客\" class=\"headerlink\" title=\"hexo + github 搭建属于自己的个人博客\"></a>hexo + github 搭建属于自己的个人博客</h3>","more":"<h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><p>1.<a href=\"https://nodejs.org/zh-cn/\" target=\"_blank\" rel=\"noopener\">node</a>：安装node，到官网下载，一路安装即可，在命令行输入node -v，出现版本号安装成功。</p>\n<p>2.<a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"noopener\">git</a>：一路安装即可，<a href=\"https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000\" target=\"_blank\" rel=\"noopener\">教程</a></p>\n<p>3.<a href=\"https://github.com/\" target=\"_blank\" rel=\"noopener\">github</a>：程序员的交流网站，用来做博客的远程创库、域名、服务器。</p>\n<p>(Mac系统下载Homebrew，直接在终端进行下载，brew install git、brew install node)</p>\n<h3 id=\"安装hexo框架\"><a href=\"#安装hexo框架\" class=\"headerlink\" title=\"安装hexo框架\"></a>安装hexo框架</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo</span><br></pre></td></tr></table></figure>\n<h3 id=\"初始化项目\"><a href=\"#初始化项目\" class=\"headerlink\" title=\"初始化项目\"></a>初始化项目</h3><p>终端cd到一个选定的目录文件下(如新建一个文件夹blog)<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo init</span><br></pre></td></tr></table></figure></p>\n<p>查看blog文件下是否存在node_modules文件夹,不在则执行如下命令<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo install</span><br></pre></td></tr></table></figure></p>\n<p>开启hexo服务器，在浏览器打开网址<a href=\"http://localhost:4000，出现hexo页面\" target=\"_blank\" rel=\"noopener\">http://localhost:4000，出现hexo页面</a><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo s</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"创建github仓库\"><a href=\"#创建github仓库\" class=\"headerlink\" title=\"创建github仓库\"></a>创建github仓库</h3><p>1.打开github，注册账号，需要和电脑关联，在本地创建ssh key，可在百度输入github与本地电脑关联</p>\n<p>2.创建github仓库,点击+号(New repository),新建仓库，名为用户名.github.io固定写法。(用户名就是自己github的名字)</p>\n<p>3.Create repository创建仓库，其它不用选择</p>\n<p>4.cd到blog文件夹，打开配置文件_config.yml<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">    <span class=\"built_in\">type</span>: git</span><br><span class=\"line\">    repository: https://github.com/xxx/xxx.github.io.git</span><br><span class=\"line\">    branch: master</span><br></pre></td></tr></table></figure></p>\n<p>你需要将repository后xxx换成你自己的用户名,浏览器输入xxx.github.io</p>\n<h3 id=\"发布文章\"><a href=\"#发布文章\" class=\"headerlink\" title=\"发布文章\"></a>发布文章</h3><p>cd到blog文件夹，执行如下命令新建文章<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo new <span class=\"string\">\"postName\"</span></span><br></pre></td></tr></table></figure></p>\n<p>名为postName的文件夹在/blog/source/_posts下。</p>\n<p>编辑文章完成，终端cd到blog文件夹下，执行如下命令<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n<h3 id=\"安装theme\"><a href=\"#安装theme\" class=\"headerlink\" title=\"安装theme\"></a>安装theme</h3><p>可以去搜索关于hexo的主题页，修饰自己的个人网站,在github上Clone or download地址<br>终端cd到blog的目录下执行如下命令<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git <span class=\"built_in\">clone</span> https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure></p>\n<p>cd到blog文件夹(每次部署文章的步骤)<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo g</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo d</span><br></pre></td></tr></table></figure>\n<p>至于更改theme内容，配置主题的网站，去修改blog/_config.yml文件和blog/themes/next/_config.yml，不要忘记冒号：加空格</p>\n<h3 id=\"绑定个人域名\"><a href=\"#绑定个人域名\" class=\"headerlink\" title=\"绑定个人域名\"></a>绑定个人域名</h3><p>1.想让自己的网站看起来更有个性，可以去万网购买喜欢的域名~~</p>\n<p>2.购买域名后，需要进行域名解析，之前先进行域名的实名验证，填写好信息，万网有详细的教程</p>\n<p>3.在blog/source建立CNAME的文件，没有后缀名，内容输入购买的域名，如<a href=\"http://www.xxx.com\" target=\"_blank\" rel=\"noopener\">www.xxx.com</a></p>\n<p>4.在万网对域名进行解析，进入解析设置，点击添加记录，需要添加4条记录<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第一条记录：</span><br><span class=\"line\">记录类型：A</span><br><span class=\"line\">主机记录:www</span><br><span class=\"line\">解析线路：默认</span><br><span class=\"line\">记录值192.30.252.154</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第二条记录：</span><br><span class=\"line\">记录类型：A</span><br><span class=\"line\">主机记录:@</span><br><span class=\"line\">解析线路：默认</span><br><span class=\"line\">记录值192.30.252.154</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第三条记录：</span><br><span class=\"line\">记录类型：A</span><br><span class=\"line\">主机记录:www</span><br><span class=\"line\">解析线路：默认</span><br><span class=\"line\">记录值192.30.252.153</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">第四条记录：</span><br><span class=\"line\">记录类型：A</span><br><span class=\"line\">主机记录:@</span><br><span class=\"line\">解析线路：默认</span><br><span class=\"line\">记录值192.30.252.153</span><br></pre></td></tr></table></figure>\n<h3 id=\"总结和说明\"><a href=\"#总结和说明\" class=\"headerlink\" title=\"总结和说明\"></a>总结和说明</h3><p>hexo + github搭建个人网站非常简单，主要在域名解析部分，当时各种解析添加记录都无法进行解析，这4条记录一定得添加好，绑定属于自己的域名。<br>搭建属于自己的个人网站成就感满满，也希望自己一直坚持写博客，把自己遇到的问题和所做的收获一点一滴记录起来。明天是国庆节，国庆节快乐！！！</p>"},{"title":"element上传图片el-upload","date":"2019-04-09T14:12:12.000Z","_content":"\n### element上传图片el-upload\n<!-- more -->\n### el-upload组件\n```\n<el-upload   \n    action=\"\"                                             \n    list-type=\"picture-card\"\n    :on-change=\"uploadChange\"\n    :file-list=\"fileList\"\n    :limit=\"5\"                          \n    :auto-upload=\"false\">                           \n    <i class=\"el-icon-plus\"></i>\n</el-upload>\n```\nlist-type:文件上传类型，如照片墙、单个上传照片\non-change:自定义上传图片\nfile-list:照片墙的数据\nlimit: 最大允许上传个数\nauto-upload:el-upload 会自动上传两次，false不自动上传\n\n### 获取base64\n```\nuploadChange(file,fileList) {\n    var reader = new FileReader();\n    reader.readAsDataURL(file.raw);\n    reader.onload = (e) =>{ \n        //reader.result获取base64\n        let imgStr = reader.result\n    }  \n}\n```\n","source":"_posts/ele-upload.md","raw":"---\ntitle: element上传图片el-upload\ndate: 2019-04-09 22:12:12\ntags: ['JavaScript']\ncategories: JavaScript\n---\n\n### element上传图片el-upload\n<!-- more -->\n### el-upload组件\n```\n<el-upload   \n    action=\"\"                                             \n    list-type=\"picture-card\"\n    :on-change=\"uploadChange\"\n    :file-list=\"fileList\"\n    :limit=\"5\"                          \n    :auto-upload=\"false\">                           \n    <i class=\"el-icon-plus\"></i>\n</el-upload>\n```\nlist-type:文件上传类型，如照片墙、单个上传照片\non-change:自定义上传图片\nfile-list:照片墙的数据\nlimit: 最大允许上传个数\nauto-upload:el-upload 会自动上传两次，false不自动上传\n\n### 获取base64\n```\nuploadChange(file,fileList) {\n    var reader = new FileReader();\n    reader.readAsDataURL(file.raw);\n    reader.onload = (e) =>{ \n        //reader.result获取base64\n        let imgStr = reader.result\n    }  \n}\n```\n","slug":"ele-upload","published":1,"updated":"2019-04-09T14:19:39.298Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuowpbs30012ja6j0hngohmo","content":"<h3 id=\"element上传图片el-upload\"><a href=\"#element上传图片el-upload\" class=\"headerlink\" title=\"element上传图片el-upload\"></a>element上传图片el-upload</h3><a id=\"more\"></a>\n<h3 id=\"el-upload组件\"><a href=\"#el-upload组件\" class=\"headerlink\" title=\"el-upload组件\"></a>el-upload组件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;el-upload   </span><br><span class=\"line\">    action=&quot;&quot;                                             </span><br><span class=\"line\">    list-type=&quot;picture-card&quot;</span><br><span class=\"line\">    :on-change=&quot;uploadChange&quot;</span><br><span class=\"line\">    :file-list=&quot;fileList&quot;</span><br><span class=\"line\">    :limit=&quot;5&quot;                          </span><br><span class=\"line\">    :auto-upload=&quot;false&quot;&gt;                           </span><br><span class=\"line\">    &lt;i class=&quot;el-icon-plus&quot;&gt;&lt;/i&gt;</span><br><span class=\"line\">&lt;/el-upload&gt;</span><br></pre></td></tr></table></figure>\n<p>list-type:文件上传类型，如照片墙、单个上传照片<br>on-change:自定义上传图片<br>file-list:照片墙的数据<br>limit: 最大允许上传个数<br>auto-upload:el-upload 会自动上传两次，false不自动上传</p>\n<h3 id=\"获取base64\"><a href=\"#获取base64\" class=\"headerlink\" title=\"获取base64\"></a>获取base64</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uploadChange(file,fileList) &#123;</span><br><span class=\"line\">    var reader = new FileReader();</span><br><span class=\"line\">    reader.readAsDataURL(file.raw);</span><br><span class=\"line\">    reader.onload = (e) =&gt;&#123; </span><br><span class=\"line\">        //reader.result获取base64</span><br><span class=\"line\">        let imgStr = reader.result</span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"element上传图片el-upload\"><a href=\"#element上传图片el-upload\" class=\"headerlink\" title=\"element上传图片el-upload\"></a>element上传图片el-upload</h3>","more":"<h3 id=\"el-upload组件\"><a href=\"#el-upload组件\" class=\"headerlink\" title=\"el-upload组件\"></a>el-upload组件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;el-upload   </span><br><span class=\"line\">    action=&quot;&quot;                                             </span><br><span class=\"line\">    list-type=&quot;picture-card&quot;</span><br><span class=\"line\">    :on-change=&quot;uploadChange&quot;</span><br><span class=\"line\">    :file-list=&quot;fileList&quot;</span><br><span class=\"line\">    :limit=&quot;5&quot;                          </span><br><span class=\"line\">    :auto-upload=&quot;false&quot;&gt;                           </span><br><span class=\"line\">    &lt;i class=&quot;el-icon-plus&quot;&gt;&lt;/i&gt;</span><br><span class=\"line\">&lt;/el-upload&gt;</span><br></pre></td></tr></table></figure>\n<p>list-type:文件上传类型，如照片墙、单个上传照片<br>on-change:自定义上传图片<br>file-list:照片墙的数据<br>limit: 最大允许上传个数<br>auto-upload:el-upload 会自动上传两次，false不自动上传</p>\n<h3 id=\"获取base64\"><a href=\"#获取base64\" class=\"headerlink\" title=\"获取base64\"></a>获取base64</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">uploadChange(file,fileList) &#123;</span><br><span class=\"line\">    var reader = new FileReader();</span><br><span class=\"line\">    reader.readAsDataURL(file.raw);</span><br><span class=\"line\">    reader.onload = (e) =&gt;&#123; </span><br><span class=\"line\">        //reader.result获取base64</span><br><span class=\"line\">        let imgStr = reader.result</span><br><span class=\"line\">    &#125;  </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"H5的支付","date":"2018-09-30T16:00:00.000Z","_content":"### JSSDK微信支付、h5浏览器支付宝支付、微信h5支付\n<!-- more -->\n\n### 微信支付\n#### 引入JS文件\n```\nhttp://res2.wx.qq.com/open/js/jweixin-1.4.0.js \n```\n#### 通过config接口注入权限验证配置\n使用JSSDK的页面必须先配置信息，否则无法使用。配置的信息通过后端接口返回，前端调用。\nchooseWXPay:微信支付的接口\n```\nwx.config({\n    debug: true, // 开启调试模式\n    appId: '', // 必填，公众号的唯一标识\n    timestamp: , // 必填，生成签名的时间戳\n    nonceStr: '', // 必填，生成签名的随机串\n    signature: '',// 必填，签名\n    jsApiList: ['chooseWXPay'] // 必填，需要使用的JS接口列表\n});\n```\n#### 通过ready接口处理成功验证\nconfig信息验证后会执行ready方法，所有接口调用都必须在config接口获得结果之后，config是一个客户端的异步操作，所以如果需要在页面加载时就调用相关接口，则须把相关接口放在ready函数中调用来确保正确执行。对于用户触发时才调用的接口，则可以直接调用，不需要放在ready函数中。\n```\nwx.ready(function(){\n    wx.chooseWXPay({\n        timestamp: , // 支付签名时间戳\n        nonceStr: , // 支付签名随机串，不长于 32 位\n        package:, // 统一支付接口返回的prepay_id参数值，提交格式如：prepay_id=\\*\\*\\*）\n        signType: 'MD5', // 签名方式，默认为'SHA1'，使用新版支付需传入'MD5'\n        paySign: , // 支付签名\n        success: function (res) {\n            if(res.errMsg == \"chooseWXPay:ok\"){\n                alert(\"支付成功\")\n            }else{\n                alert(res.errMsg);\n            }\n        }\n    });\n});\n```\n1.坑：当支付成功时，前端看到支付成功，有个坑可能会出现，就是后端订单的支付信息可能会显示未支付状态\n2.出现的原因：用户支付完成，直接退出，后端未接收到支付完成的回调\n3.解决方法：后端提供支付订单状态接口，在支付成功时调用后端接口来确认订单支付状态\n\n### 非微信浏览器的微信h5支付\n```\nwxpay.mweb_url,直接从后台返回的URL跳转唤起微信支付\nwindow.location.href = wxpay.mweb_url\n```\n后端接口返回wxpay参数下面的mweb_url,前端跳转唤起微信支付即可，前端无需做任何处理\n### 支付宝支付\n1.关于在h5浏览器的支付宝支付，前端直接调用后端接口\n2.后端提供接口alipay里有关于html页面，显示支付宝支付页面，继续支付和已完成支付，点击继续支付即可完成支付\n3.坑：后端提供的接口是否可以跳转支付页面，需要前后端联调\n前端处理\n```\nres => {    \n    const div = document.createElement('div');\n    div.innerHTML = res.html; //接口返回的html\n    document.body.appendChild(div);\n    document.forms.alipaysubmit.submit(); \n}\n```\n","source":"_posts/h5-pay.md","raw":"---\ntitle: H5的支付\ndate: 2018-10-01\ntags: ['wx.chooseWXPay','Alipay']\ncategories: H5\n---\n### JSSDK微信支付、h5浏览器支付宝支付、微信h5支付\n<!-- more -->\n\n### 微信支付\n#### 引入JS文件\n```\nhttp://res2.wx.qq.com/open/js/jweixin-1.4.0.js \n```\n#### 通过config接口注入权限验证配置\n使用JSSDK的页面必须先配置信息，否则无法使用。配置的信息通过后端接口返回，前端调用。\nchooseWXPay:微信支付的接口\n```\nwx.config({\n    debug: true, // 开启调试模式\n    appId: '', // 必填，公众号的唯一标识\n    timestamp: , // 必填，生成签名的时间戳\n    nonceStr: '', // 必填，生成签名的随机串\n    signature: '',// 必填，签名\n    jsApiList: ['chooseWXPay'] // 必填，需要使用的JS接口列表\n});\n```\n#### 通过ready接口处理成功验证\nconfig信息验证后会执行ready方法，所有接口调用都必须在config接口获得结果之后，config是一个客户端的异步操作，所以如果需要在页面加载时就调用相关接口，则须把相关接口放在ready函数中调用来确保正确执行。对于用户触发时才调用的接口，则可以直接调用，不需要放在ready函数中。\n```\nwx.ready(function(){\n    wx.chooseWXPay({\n        timestamp: , // 支付签名时间戳\n        nonceStr: , // 支付签名随机串，不长于 32 位\n        package:, // 统一支付接口返回的prepay_id参数值，提交格式如：prepay_id=\\*\\*\\*）\n        signType: 'MD5', // 签名方式，默认为'SHA1'，使用新版支付需传入'MD5'\n        paySign: , // 支付签名\n        success: function (res) {\n            if(res.errMsg == \"chooseWXPay:ok\"){\n                alert(\"支付成功\")\n            }else{\n                alert(res.errMsg);\n            }\n        }\n    });\n});\n```\n1.坑：当支付成功时，前端看到支付成功，有个坑可能会出现，就是后端订单的支付信息可能会显示未支付状态\n2.出现的原因：用户支付完成，直接退出，后端未接收到支付完成的回调\n3.解决方法：后端提供支付订单状态接口，在支付成功时调用后端接口来确认订单支付状态\n\n### 非微信浏览器的微信h5支付\n```\nwxpay.mweb_url,直接从后台返回的URL跳转唤起微信支付\nwindow.location.href = wxpay.mweb_url\n```\n后端接口返回wxpay参数下面的mweb_url,前端跳转唤起微信支付即可，前端无需做任何处理\n### 支付宝支付\n1.关于在h5浏览器的支付宝支付，前端直接调用后端接口\n2.后端提供接口alipay里有关于html页面，显示支付宝支付页面，继续支付和已完成支付，点击继续支付即可完成支付\n3.坑：后端提供的接口是否可以跳转支付页面，需要前后端联调\n前端处理\n```\nres => {    \n    const div = document.createElement('div');\n    div.innerHTML = res.html; //接口返回的html\n    document.body.appendChild(div);\n    document.forms.alipaysubmit.submit(); \n}\n```\n","slug":"h5-pay","published":1,"updated":"2018-10-09T15:01:50.246Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuowpbs40016ja6jsisbmgrj","content":"<h3 id=\"JSSDK微信支付、h5浏览器支付宝支付、微信h5支付\"><a href=\"#JSSDK微信支付、h5浏览器支付宝支付、微信h5支付\" class=\"headerlink\" title=\"JSSDK微信支付、h5浏览器支付宝支付、微信h5支付\"></a>JSSDK微信支付、h5浏览器支付宝支付、微信h5支付</h3><a id=\"more\"></a>\n<h3 id=\"微信支付\"><a href=\"#微信支付\" class=\"headerlink\" title=\"微信支付\"></a>微信支付</h3><h4 id=\"引入JS文件\"><a href=\"#引入JS文件\" class=\"headerlink\" title=\"引入JS文件\"></a>引入JS文件</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://res2.wx.qq.com/open/js/jweixin-1.4.0.js</span><br></pre></td></tr></table></figure>\n<h4 id=\"通过config接口注入权限验证配置\"><a href=\"#通过config接口注入权限验证配置\" class=\"headerlink\" title=\"通过config接口注入权限验证配置\"></a>通过config接口注入权限验证配置</h4><p>使用JSSDK的页面必须先配置信息，否则无法使用。配置的信息通过后端接口返回，前端调用。<br>chooseWXPay:微信支付的接口<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wx.config(&#123;</span><br><span class=\"line\">    debug: true, // 开启调试模式</span><br><span class=\"line\">    appId: &apos;&apos;, // 必填，公众号的唯一标识</span><br><span class=\"line\">    timestamp: , // 必填，生成签名的时间戳</span><br><span class=\"line\">    nonceStr: &apos;&apos;, // 必填，生成签名的随机串</span><br><span class=\"line\">    signature: &apos;&apos;,// 必填，签名</span><br><span class=\"line\">    jsApiList: [&apos;chooseWXPay&apos;] // 必填，需要使用的JS接口列表</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"通过ready接口处理成功验证\"><a href=\"#通过ready接口处理成功验证\" class=\"headerlink\" title=\"通过ready接口处理成功验证\"></a>通过ready接口处理成功验证</h4><p>config信息验证后会执行ready方法，所有接口调用都必须在config接口获得结果之后，config是一个客户端的异步操作，所以如果需要在页面加载时就调用相关接口，则须把相关接口放在ready函数中调用来确保正确执行。对于用户触发时才调用的接口，则可以直接调用，不需要放在ready函数中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wx.ready(function()&#123;</span><br><span class=\"line\">    wx.chooseWXPay(&#123;</span><br><span class=\"line\">        timestamp: , // 支付签名时间戳</span><br><span class=\"line\">        nonceStr: , // 支付签名随机串，不长于 32 位</span><br><span class=\"line\">        package:, // 统一支付接口返回的prepay_id参数值，提交格式如：prepay_id=\\*\\*\\*）</span><br><span class=\"line\">        signType: &apos;MD5&apos;, // 签名方式，默认为&apos;SHA1&apos;，使用新版支付需传入&apos;MD5&apos;</span><br><span class=\"line\">        paySign: , // 支付签名</span><br><span class=\"line\">        success: function (res) &#123;</span><br><span class=\"line\">            if(res.errMsg == &quot;chooseWXPay:ok&quot;)&#123;</span><br><span class=\"line\">                alert(&quot;支付成功&quot;)</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                alert(res.errMsg);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>1.坑：当支付成功时，前端看到支付成功，有个坑可能会出现，就是后端订单的支付信息可能会显示未支付状态<br>2.出现的原因：用户支付完成，直接退出，后端未接收到支付完成的回调<br>3.解决方法：后端提供支付订单状态接口，在支付成功时调用后端接口来确认订单支付状态</p>\n<h3 id=\"非微信浏览器的微信h5支付\"><a href=\"#非微信浏览器的微信h5支付\" class=\"headerlink\" title=\"非微信浏览器的微信h5支付\"></a>非微信浏览器的微信h5支付</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wxpay.mweb_url,直接从后台返回的URL跳转唤起微信支付</span><br><span class=\"line\">window.location.href = wxpay.mweb_url</span><br></pre></td></tr></table></figure>\n<p>后端接口返回wxpay参数下面的mweb_url,前端跳转唤起微信支付即可，前端无需做任何处理</p>\n<h3 id=\"支付宝支付\"><a href=\"#支付宝支付\" class=\"headerlink\" title=\"支付宝支付\"></a>支付宝支付</h3><p>1.关于在h5浏览器的支付宝支付，前端直接调用后端接口<br>2.后端提供接口alipay里有关于html页面，显示支付宝支付页面，继续支付和已完成支付，点击继续支付即可完成支付<br>3.坑：后端提供的接口是否可以跳转支付页面，需要前后端联调<br>前端处理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res =&gt; &#123;    </span><br><span class=\"line\">    const div = document.createElement(&apos;div&apos;);</span><br><span class=\"line\">    div.innerHTML = res.html; //接口返回的html</span><br><span class=\"line\">    document.body.appendChild(div);</span><br><span class=\"line\">    document.forms.alipaysubmit.submit(); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"JSSDK微信支付、h5浏览器支付宝支付、微信h5支付\"><a href=\"#JSSDK微信支付、h5浏览器支付宝支付、微信h5支付\" class=\"headerlink\" title=\"JSSDK微信支付、h5浏览器支付宝支付、微信h5支付\"></a>JSSDK微信支付、h5浏览器支付宝支付、微信h5支付</h3>","more":"<h3 id=\"微信支付\"><a href=\"#微信支付\" class=\"headerlink\" title=\"微信支付\"></a>微信支付</h3><h4 id=\"引入JS文件\"><a href=\"#引入JS文件\" class=\"headerlink\" title=\"引入JS文件\"></a>引入JS文件</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http://res2.wx.qq.com/open/js/jweixin-1.4.0.js</span><br></pre></td></tr></table></figure>\n<h4 id=\"通过config接口注入权限验证配置\"><a href=\"#通过config接口注入权限验证配置\" class=\"headerlink\" title=\"通过config接口注入权限验证配置\"></a>通过config接口注入权限验证配置</h4><p>使用JSSDK的页面必须先配置信息，否则无法使用。配置的信息通过后端接口返回，前端调用。<br>chooseWXPay:微信支付的接口<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wx.config(&#123;</span><br><span class=\"line\">    debug: true, // 开启调试模式</span><br><span class=\"line\">    appId: &apos;&apos;, // 必填，公众号的唯一标识</span><br><span class=\"line\">    timestamp: , // 必填，生成签名的时间戳</span><br><span class=\"line\">    nonceStr: &apos;&apos;, // 必填，生成签名的随机串</span><br><span class=\"line\">    signature: &apos;&apos;,// 必填，签名</span><br><span class=\"line\">    jsApiList: [&apos;chooseWXPay&apos;] // 必填，需要使用的JS接口列表</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"通过ready接口处理成功验证\"><a href=\"#通过ready接口处理成功验证\" class=\"headerlink\" title=\"通过ready接口处理成功验证\"></a>通过ready接口处理成功验证</h4><p>config信息验证后会执行ready方法，所有接口调用都必须在config接口获得结果之后，config是一个客户端的异步操作，所以如果需要在页面加载时就调用相关接口，则须把相关接口放在ready函数中调用来确保正确执行。对于用户触发时才调用的接口，则可以直接调用，不需要放在ready函数中。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wx.ready(function()&#123;</span><br><span class=\"line\">    wx.chooseWXPay(&#123;</span><br><span class=\"line\">        timestamp: , // 支付签名时间戳</span><br><span class=\"line\">        nonceStr: , // 支付签名随机串，不长于 32 位</span><br><span class=\"line\">        package:, // 统一支付接口返回的prepay_id参数值，提交格式如：prepay_id=\\*\\*\\*）</span><br><span class=\"line\">        signType: &apos;MD5&apos;, // 签名方式，默认为&apos;SHA1&apos;，使用新版支付需传入&apos;MD5&apos;</span><br><span class=\"line\">        paySign: , // 支付签名</span><br><span class=\"line\">        success: function (res) &#123;</span><br><span class=\"line\">            if(res.errMsg == &quot;chooseWXPay:ok&quot;)&#123;</span><br><span class=\"line\">                alert(&quot;支付成功&quot;)</span><br><span class=\"line\">            &#125;else&#123;</span><br><span class=\"line\">                alert(res.errMsg);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<p>1.坑：当支付成功时，前端看到支付成功，有个坑可能会出现，就是后端订单的支付信息可能会显示未支付状态<br>2.出现的原因：用户支付完成，直接退出，后端未接收到支付完成的回调<br>3.解决方法：后端提供支付订单状态接口，在支付成功时调用后端接口来确认订单支付状态</p>\n<h3 id=\"非微信浏览器的微信h5支付\"><a href=\"#非微信浏览器的微信h5支付\" class=\"headerlink\" title=\"非微信浏览器的微信h5支付\"></a>非微信浏览器的微信h5支付</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wxpay.mweb_url,直接从后台返回的URL跳转唤起微信支付</span><br><span class=\"line\">window.location.href = wxpay.mweb_url</span><br></pre></td></tr></table></figure>\n<p>后端接口返回wxpay参数下面的mweb_url,前端跳转唤起微信支付即可，前端无需做任何处理</p>\n<h3 id=\"支付宝支付\"><a href=\"#支付宝支付\" class=\"headerlink\" title=\"支付宝支付\"></a>支付宝支付</h3><p>1.关于在h5浏览器的支付宝支付，前端直接调用后端接口<br>2.后端提供接口alipay里有关于html页面，显示支付宝支付页面，继续支付和已完成支付，点击继续支付即可完成支付<br>3.坑：后端提供的接口是否可以跳转支付页面，需要前后端联调<br>前端处理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">res =&gt; &#123;    </span><br><span class=\"line\">    const div = document.createElement(&apos;div&apos;);</span><br><span class=\"line\">    div.innerHTML = res.html; //接口返回的html</span><br><span class=\"line\">    document.body.appendChild(div);</span><br><span class=\"line\">    document.forms.alipaysubmit.submit(); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>"},{"title":"JavaScript的作用域和变量提升、函数声明","date":"2019-01-03T15:03:37.000Z","_content":"\n### 什么是作用域\n<!-- more -->\n1. 作用域就是指程序源代码定义变量的区域。\n2. 作用域规定如何查找变量，确定对当前执行代码对变量对访问权限。\n```\nvar value = 1;\n\nfunction foo() {\n    console.log(value);\n}\n\nfunction bar() {\n    var value = 2;\n    foo();\n}\n\nbar();\n```\n首先是bar()函数执行，在bar()函数内部foo()函数执行，先在foo函数对当前作用域进行查找，如果没有，则查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。\n\n### 顺序执行\n```\nvar foo = function () {\n\n    console.log('foo1');\n\n}\n\nfoo();  // foo1\n\nvar foo = function () {\n\n    console.log('foo2');\n\n}\n\nfoo(); // foo2\n```\n```\nfunction foo() {\n\n    console.log('foo1');\n\n}\n\nfoo();  // foo2\n\nfunction foo() {\n\n    console.log('foo2');\n\n}\n\nfoo(); // foo2\n```\n JavaScript 引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。当执行一段代码的时候，会进行一个“准备工作”，比如第一个例子中的变量提升，和第二个例子中的函数提升。\n\n ### 变量提升\n 1. 通常JS引擎会在正式执行之前先进行一次预编译，在这个过程中，首先将变量声明及函数声明提升至当前作用域的顶端，然后进行接下来的处理。\n 2. 如果在当前作用域存在此声明对变量，无论它在什么地方声明，引用此变量时就会在当前作用域中查找，不会去外层作用域了。\n ```\nvar foo = 3;\n\nfunction hoistVariable() {\n\n    var foo = foo || 5;\n\n    console.log(foo); // 5\n}\n\nhoistVariable();\n ```\n 虽然外层作用域有个foo变量，但函数内是不会去引用的。先在当前作用域寻找foo变量，如果当前作用域foo不存在，则通过作用域链往上继续找foo变量，如果继续不存在而又未定义则报错。\n\n ### 函数提升\n 1. 为什么函数可以在声明之前就可以调用，并且跟变量声明不同的是，它还能得到正确的结果，其实引擎是把函数声明整个地提升到了当前作用域的顶部\n ```\n function hoistFunction() {\n    foo(); // output: I am hoisted\n\n    function foo() {\n        console.log('I am hoisted');\n    }\n}\n\nhoistFunction();\n ```\n 2. 如果在同一个作用域中存在多个同名函数声明，后面出现的将会覆盖前面的函数声明：\n ```\n function hoistFunction() {\n    function foo() {\n        console.log(1);\n    }\n\n    foo(); // output: 2\n\n    function foo() {\n        console.log(2);\n    }\n}\n\nhoistFunction();\n ```\n 3. 函数声明和函数表达式\n ```\n// 函数声明\nfunction foo() {\n    console.log('function declaration');\n}\n\n// 匿名函数表达式\nvar foo = function() {\n    console.log('anonymous function expression');\n};\n\n// 具名函数表达式\nvar foo = function bar() {\n    console.log('named function expression');\n};\n ```\n1. 匿名函数表达式，其实是将一个不带名字的函数声明赋值给了一个变量，\n2. 具名函数表达式，则是带名字的函数赋值给一个变量，需要注意到是，这个函数名只能在此函数内部使用。\n3. 函数表达式可以通过变量访问，所以也存在变量提升同样的效果。\n4. 函数的优先权是最高的，它永远被提升至作用域最顶部，然后才是函数表达式和变量按顺序执行\n","source":"_posts/js-shangxiawen.md","raw":"---\ntitle: JavaScript的作用域和变量提升、函数声明\ndate: 2019-01-03 23:03:37\ntags: ['JavaScript']\ncategories: JavaScript\n---\n\n### 什么是作用域\n<!-- more -->\n1. 作用域就是指程序源代码定义变量的区域。\n2. 作用域规定如何查找变量，确定对当前执行代码对变量对访问权限。\n```\nvar value = 1;\n\nfunction foo() {\n    console.log(value);\n}\n\nfunction bar() {\n    var value = 2;\n    foo();\n}\n\nbar();\n```\n首先是bar()函数执行，在bar()函数内部foo()函数执行，先在foo函数对当前作用域进行查找，如果没有，则查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。\n\n### 顺序执行\n```\nvar foo = function () {\n\n    console.log('foo1');\n\n}\n\nfoo();  // foo1\n\nvar foo = function () {\n\n    console.log('foo2');\n\n}\n\nfoo(); // foo2\n```\n```\nfunction foo() {\n\n    console.log('foo1');\n\n}\n\nfoo();  // foo2\n\nfunction foo() {\n\n    console.log('foo2');\n\n}\n\nfoo(); // foo2\n```\n JavaScript 引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。当执行一段代码的时候，会进行一个“准备工作”，比如第一个例子中的变量提升，和第二个例子中的函数提升。\n\n ### 变量提升\n 1. 通常JS引擎会在正式执行之前先进行一次预编译，在这个过程中，首先将变量声明及函数声明提升至当前作用域的顶端，然后进行接下来的处理。\n 2. 如果在当前作用域存在此声明对变量，无论它在什么地方声明，引用此变量时就会在当前作用域中查找，不会去外层作用域了。\n ```\nvar foo = 3;\n\nfunction hoistVariable() {\n\n    var foo = foo || 5;\n\n    console.log(foo); // 5\n}\n\nhoistVariable();\n ```\n 虽然外层作用域有个foo变量，但函数内是不会去引用的。先在当前作用域寻找foo变量，如果当前作用域foo不存在，则通过作用域链往上继续找foo变量，如果继续不存在而又未定义则报错。\n\n ### 函数提升\n 1. 为什么函数可以在声明之前就可以调用，并且跟变量声明不同的是，它还能得到正确的结果，其实引擎是把函数声明整个地提升到了当前作用域的顶部\n ```\n function hoistFunction() {\n    foo(); // output: I am hoisted\n\n    function foo() {\n        console.log('I am hoisted');\n    }\n}\n\nhoistFunction();\n ```\n 2. 如果在同一个作用域中存在多个同名函数声明，后面出现的将会覆盖前面的函数声明：\n ```\n function hoistFunction() {\n    function foo() {\n        console.log(1);\n    }\n\n    foo(); // output: 2\n\n    function foo() {\n        console.log(2);\n    }\n}\n\nhoistFunction();\n ```\n 3. 函数声明和函数表达式\n ```\n// 函数声明\nfunction foo() {\n    console.log('function declaration');\n}\n\n// 匿名函数表达式\nvar foo = function() {\n    console.log('anonymous function expression');\n};\n\n// 具名函数表达式\nvar foo = function bar() {\n    console.log('named function expression');\n};\n ```\n1. 匿名函数表达式，其实是将一个不带名字的函数声明赋值给了一个变量，\n2. 具名函数表达式，则是带名字的函数赋值给一个变量，需要注意到是，这个函数名只能在此函数内部使用。\n3. 函数表达式可以通过变量访问，所以也存在变量提升同样的效果。\n4. 函数的优先权是最高的，它永远被提升至作用域最顶部，然后才是函数表达式和变量按顺序执行\n","slug":"js-shangxiawen","published":1,"updated":"2019-01-03T15:27:18.058Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuowpbs50019ja6jjfkf8ne3","content":"<h3 id=\"什么是作用域\"><a href=\"#什么是作用域\" class=\"headerlink\" title=\"什么是作用域\"></a>什么是作用域</h3><a id=\"more\"></a>\n<ol>\n<li>作用域就是指程序源代码定义变量的区域。</li>\n<li>作用域规定如何查找变量，确定对当前执行代码对变量对访问权限。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var value = 1;</span><br><span class=\"line\"></span><br><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">    console.log(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function bar() &#123;</span><br><span class=\"line\">    var value = 2;</span><br><span class=\"line\">    foo();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bar();</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>首先是bar()函数执行，在bar()函数内部foo()函数执行，先在foo函数对当前作用域进行查找，如果没有，则查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。</p>\n<h3 id=\"顺序执行\"><a href=\"#顺序执行\" class=\"headerlink\" title=\"顺序执行\"></a>顺序执行</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var foo = function () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(&apos;foo1&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo();  // foo1</span><br><span class=\"line\"></span><br><span class=\"line\">var foo = function () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(&apos;foo2&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(); // foo2</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(&apos;foo1&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo();  // foo2</span><br><span class=\"line\"></span><br><span class=\"line\">function foo() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(&apos;foo2&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(); // foo2</span><br></pre></td></tr></table></figure>\n<p> JavaScript 引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。当执行一段代码的时候，会进行一个“准备工作”，比如第一个例子中的变量提升，和第二个例子中的函数提升。</p>\n<h3 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h3><ol>\n<li>通常JS引擎会在正式执行之前先进行一次预编译，在这个过程中，首先将变量声明及函数声明提升至当前作用域的顶端，然后进行接下来的处理。</li>\n<li><p>如果在当前作用域存在此声明对变量，无论它在什么地方声明，引用此变量时就会在当前作用域中查找，不会去外层作用域了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var foo = 3;</span><br><span class=\"line\"></span><br><span class=\"line\">function hoistVariable() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    var foo = foo || 5;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(foo); // 5</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hoistVariable();</span><br></pre></td></tr></table></figure>\n<p>虽然外层作用域有个foo变量，但函数内是不会去引用的。先在当前作用域寻找foo变量，如果当前作用域foo不存在，则通过作用域链往上继续找foo变量，如果继续不存在而又未定义则报错。</p>\n<h3 id=\"函数提升\"><a href=\"#函数提升\" class=\"headerlink\" title=\"函数提升\"></a>函数提升</h3></li>\n<li><p>为什么函数可以在声明之前就可以调用，并且跟变量声明不同的是，它还能得到正确的结果，其实引擎是把函数声明整个地提升到了当前作用域的顶部</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> function hoistFunction() &#123;</span><br><span class=\"line\">    foo(); // output: I am hoisted</span><br><span class=\"line\"></span><br><span class=\"line\">    function foo() &#123;</span><br><span class=\"line\">        console.log(&apos;I am hoisted&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hoistFunction();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果在同一个作用域中存在多个同名函数声明，后面出现的将会覆盖前面的函数声明：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> function hoistFunction() &#123;</span><br><span class=\"line\">    function foo() &#123;</span><br><span class=\"line\">        console.log(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    foo(); // output: 2</span><br><span class=\"line\"></span><br><span class=\"line\">    function foo() &#123;</span><br><span class=\"line\">        console.log(2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hoistFunction();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>函数声明和函数表达式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 函数声明</span><br><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">    console.log(&apos;function declaration&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匿名函数表达式</span><br><span class=\"line\">var foo = function() &#123;</span><br><span class=\"line\">    console.log(&apos;anonymous function expression&apos;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 具名函数表达式</span><br><span class=\"line\">var foo = function bar() &#123;</span><br><span class=\"line\">    console.log(&apos;named function expression&apos;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li>匿名函数表达式，其实是将一个不带名字的函数声明赋值给了一个变量，</li>\n<li>具名函数表达式，则是带名字的函数赋值给一个变量，需要注意到是，这个函数名只能在此函数内部使用。</li>\n<li>函数表达式可以通过变量访问，所以也存在变量提升同样的效果。</li>\n<li>函数的优先权是最高的，它永远被提升至作用域最顶部，然后才是函数表达式和变量按顺序执行</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"什么是作用域\"><a href=\"#什么是作用域\" class=\"headerlink\" title=\"什么是作用域\"></a>什么是作用域</h3>","more":"<ol>\n<li>作用域就是指程序源代码定义变量的区域。</li>\n<li>作用域规定如何查找变量，确定对当前执行代码对变量对访问权限。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var value = 1;</span><br><span class=\"line\"></span><br><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">    console.log(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function bar() &#123;</span><br><span class=\"line\">    var value = 2;</span><br><span class=\"line\">    foo();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">bar();</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>首先是bar()函数执行，在bar()函数内部foo()函数执行，先在foo函数对当前作用域进行查找，如果没有，则查找上面一层的代码，也就是 value 等于 1，所以结果会打印 1。</p>\n<h3 id=\"顺序执行\"><a href=\"#顺序执行\" class=\"headerlink\" title=\"顺序执行\"></a>顺序执行</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var foo = function () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(&apos;foo1&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo();  // foo1</span><br><span class=\"line\"></span><br><span class=\"line\">var foo = function () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(&apos;foo2&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(); // foo2</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function foo() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(&apos;foo1&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo();  // foo2</span><br><span class=\"line\"></span><br><span class=\"line\">function foo() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(&apos;foo2&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">foo(); // foo2</span><br></pre></td></tr></table></figure>\n<p> JavaScript 引擎并非一行一行地分析和执行程序，而是一段一段地分析执行。当执行一段代码的时候，会进行一个“准备工作”，比如第一个例子中的变量提升，和第二个例子中的函数提升。</p>\n<h3 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h3><ol>\n<li>通常JS引擎会在正式执行之前先进行一次预编译，在这个过程中，首先将变量声明及函数声明提升至当前作用域的顶端，然后进行接下来的处理。</li>\n<li><p>如果在当前作用域存在此声明对变量，无论它在什么地方声明，引用此变量时就会在当前作用域中查找，不会去外层作用域了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var foo = 3;</span><br><span class=\"line\"></span><br><span class=\"line\">function hoistVariable() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    var foo = foo || 5;</span><br><span class=\"line\"></span><br><span class=\"line\">    console.log(foo); // 5</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hoistVariable();</span><br></pre></td></tr></table></figure>\n<p>虽然外层作用域有个foo变量，但函数内是不会去引用的。先在当前作用域寻找foo变量，如果当前作用域foo不存在，则通过作用域链往上继续找foo变量，如果继续不存在而又未定义则报错。</p>\n<h3 id=\"函数提升\"><a href=\"#函数提升\" class=\"headerlink\" title=\"函数提升\"></a>函数提升</h3></li>\n<li><p>为什么函数可以在声明之前就可以调用，并且跟变量声明不同的是，它还能得到正确的结果，其实引擎是把函数声明整个地提升到了当前作用域的顶部</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> function hoistFunction() &#123;</span><br><span class=\"line\">    foo(); // output: I am hoisted</span><br><span class=\"line\"></span><br><span class=\"line\">    function foo() &#123;</span><br><span class=\"line\">        console.log(&apos;I am hoisted&apos;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hoistFunction();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果在同一个作用域中存在多个同名函数声明，后面出现的将会覆盖前面的函数声明：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> function hoistFunction() &#123;</span><br><span class=\"line\">    function foo() &#123;</span><br><span class=\"line\">        console.log(1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    foo(); // output: 2</span><br><span class=\"line\"></span><br><span class=\"line\">    function foo() &#123;</span><br><span class=\"line\">        console.log(2);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">hoistFunction();</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>函数声明和函数表达式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 函数声明</span><br><span class=\"line\">function foo() &#123;</span><br><span class=\"line\">    console.log(&apos;function declaration&apos;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">// 匿名函数表达式</span><br><span class=\"line\">var foo = function() &#123;</span><br><span class=\"line\">    console.log(&apos;anonymous function expression&apos;);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 具名函数表达式</span><br><span class=\"line\">var foo = function bar() &#123;</span><br><span class=\"line\">    console.log(&apos;named function expression&apos;);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ol>\n<li>匿名函数表达式，其实是将一个不带名字的函数声明赋值给了一个变量，</li>\n<li>具名函数表达式，则是带名字的函数赋值给一个变量，需要注意到是，这个函数名只能在此函数内部使用。</li>\n<li>函数表达式可以通过变量访问，所以也存在变量提升同样的效果。</li>\n<li>函数的优先权是最高的，它永远被提升至作用域最顶部，然后才是函数表达式和变量按顺序执行</li>\n</ol>"},{"title":"React RouterV4","date":"2019-02-24T12:27:40.000Z","_content":"### React Router\n<!-- more -->\n\n### react-router和react-router-dom理解\n1. react-router\n提供了一些router的核心api,包括Router,Route,Switch等\n\n2.react-router-dom\n提供了BrowserRouter,HashRouter,Route,Link,NavLink\n\n### react-router-dom核心用法\n1.HashRouter和BrowserRouter\n\n2.Route:path,exact,component,render\nRoute:路由的根基\npath:路由的匹配\nexact:精准匹配\ncomponent:渲染的 React 组件\nrender:方便的内联渲染和包裹\n\n3.NavLink,Link\nLink:导航，路由跳转\n\n4.Switch\n渲染与该地址匹配的第一个子节点 <Route>,匹配到不会往下继续匹配。\n\n5.Redirect\n路由重定向\n\n6.HashRouter和BrowserRouter\nHashRouter: http://localhost:3000/#/admin，带有#号\nBrowserRouter:http://localhost:3000/admin,基于浏览的Router\n\n\n","source":"_posts/react-router.md","raw":"---\ntitle: React RouterV4\ndate: 2019-02-24 20:27:40\ntags: [\"React\"]\ncategories: React\n---\n### React Router\n<!-- more -->\n\n### react-router和react-router-dom理解\n1. react-router\n提供了一些router的核心api,包括Router,Route,Switch等\n\n2.react-router-dom\n提供了BrowserRouter,HashRouter,Route,Link,NavLink\n\n### react-router-dom核心用法\n1.HashRouter和BrowserRouter\n\n2.Route:path,exact,component,render\nRoute:路由的根基\npath:路由的匹配\nexact:精准匹配\ncomponent:渲染的 React 组件\nrender:方便的内联渲染和包裹\n\n3.NavLink,Link\nLink:导航，路由跳转\n\n4.Switch\n渲染与该地址匹配的第一个子节点 <Route>,匹配到不会往下继续匹配。\n\n5.Redirect\n路由重定向\n\n6.HashRouter和BrowserRouter\nHashRouter: http://localhost:3000/#/admin，带有#号\nBrowserRouter:http://localhost:3000/admin,基于浏览的Router\n\n\n","slug":"react-router","published":1,"updated":"2019-02-24T12:51:46.531Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuowpbs6001cja6jiwrvpuol","content":"<h3 id=\"React-Router\"><a href=\"#React-Router\" class=\"headerlink\" title=\"React Router\"></a>React Router</h3><a id=\"more\"></a>\n<h3 id=\"react-router和react-router-dom理解\"><a href=\"#react-router和react-router-dom理解\" class=\"headerlink\" title=\"react-router和react-router-dom理解\"></a>react-router和react-router-dom理解</h3><ol>\n<li>react-router<br>提供了一些router的核心api,包括Router,Route,Switch等</li>\n</ol>\n<p>2.react-router-dom<br>提供了BrowserRouter,HashRouter,Route,Link,NavLink</p>\n<h3 id=\"react-router-dom核心用法\"><a href=\"#react-router-dom核心用法\" class=\"headerlink\" title=\"react-router-dom核心用法\"></a>react-router-dom核心用法</h3><p>1.HashRouter和BrowserRouter</p>\n<p>2.Route:path,exact,component,render<br>Route:路由的根基<br>path:路由的匹配<br>exact:精准匹配<br>component:渲染的 React 组件<br>render:方便的内联渲染和包裹</p>\n<p>3.NavLink,Link<br>Link:导航，路由跳转</p>\n<p>4.Switch<br>渲染与该地址匹配的第一个子节点 <route>,匹配到不会往下继续匹配。</route></p>\n<p>5.Redirect<br>路由重定向</p>\n<p>6.HashRouter和BrowserRouter<br>HashRouter: <a href=\"http://localhost:3000/#/admin，带有#号\" target=\"_blank\" rel=\"noopener\">http://localhost:3000/#/admin，带有#号</a><br>BrowserRouter:<a href=\"http://localhost:3000/admin,基于浏览的Router\" target=\"_blank\" rel=\"noopener\">http://localhost:3000/admin,基于浏览的Router</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"React-Router\"><a href=\"#React-Router\" class=\"headerlink\" title=\"React Router\"></a>React Router</h3>","more":"<h3 id=\"react-router和react-router-dom理解\"><a href=\"#react-router和react-router-dom理解\" class=\"headerlink\" title=\"react-router和react-router-dom理解\"></a>react-router和react-router-dom理解</h3><ol>\n<li>react-router<br>提供了一些router的核心api,包括Router,Route,Switch等</li>\n</ol>\n<p>2.react-router-dom<br>提供了BrowserRouter,HashRouter,Route,Link,NavLink</p>\n<h3 id=\"react-router-dom核心用法\"><a href=\"#react-router-dom核心用法\" class=\"headerlink\" title=\"react-router-dom核心用法\"></a>react-router-dom核心用法</h3><p>1.HashRouter和BrowserRouter</p>\n<p>2.Route:path,exact,component,render<br>Route:路由的根基<br>path:路由的匹配<br>exact:精准匹配<br>component:渲染的 React 组件<br>render:方便的内联渲染和包裹</p>\n<p>3.NavLink,Link<br>Link:导航，路由跳转</p>\n<p>4.Switch<br>渲染与该地址匹配的第一个子节点 <route>,匹配到不会往下继续匹配。</route></p>\n<p>5.Redirect<br>路由重定向</p>\n<p>6.HashRouter和BrowserRouter<br>HashRouter: <a href=\"http://localhost:3000/#/admin，带有#号\" target=\"_blank\" rel=\"noopener\">http://localhost:3000/#/admin，带有#号</a><br>BrowserRouter:<a href=\"http://localhost:3000/admin,基于浏览的Router\" target=\"_blank\" rel=\"noopener\">http://localhost:3000/admin,基于浏览的Router</a></p>"},{"title":"moment在vue时间格式化","date":"2018-10-09T16:00:00.000Z","_content":"### Vue--moment时间格式插件安装和使用\n<!-- more -->\n\n### [moment文档](http://momentjs.cn/)\n\n### 安装插件\n```\nyarn add moment -S\n```\n\n### 导入使用\n```\nimport moment from 'moment'\n\nfilters: {\n    dateyear(time){\n        return moment(time*1000).format(\"YYYY年MM月DD日\")\n    },\n    formatDate(time) {\n        return moment(time*1000).format(\"YYYY-MM-DD HH:mm:ss\")\n    }\n},\n```\nfilters过滤器，time时间戳的形参，time为什么要乘以1000？因为我公司的后端是PHP，PHP返回的时间戳需要乘以1000,格式化的时间才准确显示。\n```\n<template>\n    <div>{{item.add_time | formatDate}}</div>\n</template>\n```\n在vue模版时间格式化的显示","source":"_posts/moment.md","raw":"---\ntitle: moment在vue时间格式化\ndate: 2018-10-10\ntags: [\"vue\"]\ncategories: vue\n---\n### Vue--moment时间格式插件安装和使用\n<!-- more -->\n\n### [moment文档](http://momentjs.cn/)\n\n### 安装插件\n```\nyarn add moment -S\n```\n\n### 导入使用\n```\nimport moment from 'moment'\n\nfilters: {\n    dateyear(time){\n        return moment(time*1000).format(\"YYYY年MM月DD日\")\n    },\n    formatDate(time) {\n        return moment(time*1000).format(\"YYYY-MM-DD HH:mm:ss\")\n    }\n},\n```\nfilters过滤器，time时间戳的形参，time为什么要乘以1000？因为我公司的后端是PHP，PHP返回的时间戳需要乘以1000,格式化的时间才准确显示。\n```\n<template>\n    <div>{{item.add_time | formatDate}}</div>\n</template>\n```\n在vue模版时间格式化的显示","slug":"moment","published":1,"updated":"2018-10-10T13:44:04.946Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuowpbs8001hja6j80y5ojg4","content":"<h3 id=\"Vue–moment时间格式插件安装和使用\"><a href=\"#Vue–moment时间格式插件安装和使用\" class=\"headerlink\" title=\"Vue–moment时间格式插件安装和使用\"></a>Vue–moment时间格式插件安装和使用</h3><a id=\"more\"></a>\n<h3 id=\"moment文档\"><a href=\"#moment文档\" class=\"headerlink\" title=\"moment文档\"></a><a href=\"http://momentjs.cn/\" target=\"_blank\" rel=\"noopener\">moment文档</a></h3><h3 id=\"安装插件\"><a href=\"#安装插件\" class=\"headerlink\" title=\"安装插件\"></a>安装插件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn add moment -S</span><br></pre></td></tr></table></figure>\n<h3 id=\"导入使用\"><a href=\"#导入使用\" class=\"headerlink\" title=\"导入使用\"></a>导入使用</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import moment from &apos;moment&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">filters: &#123;</span><br><span class=\"line\">    dateyear(time)&#123;</span><br><span class=\"line\">        return moment(time*1000).format(&quot;YYYY年MM月DD日&quot;)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    formatDate(time) &#123;</span><br><span class=\"line\">        return moment(time*1000).format(&quot;YYYY-MM-DD HH:mm:ss&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>filters过滤器，time时间戳的形参，time为什么要乘以1000？因为我公司的后端是PHP，PHP返回的时间戳需要乘以1000,格式化的时间才准确显示。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;div&gt;&#123;&#123;item.add_time | formatDate&#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p>\n<p>在vue模版时间格式化的显示</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"Vue–moment时间格式插件安装和使用\"><a href=\"#Vue–moment时间格式插件安装和使用\" class=\"headerlink\" title=\"Vue–moment时间格式插件安装和使用\"></a>Vue–moment时间格式插件安装和使用</h3>","more":"<h3 id=\"moment文档\"><a href=\"#moment文档\" class=\"headerlink\" title=\"moment文档\"></a><a href=\"http://momentjs.cn/\" target=\"_blank\" rel=\"noopener\">moment文档</a></h3><h3 id=\"安装插件\"><a href=\"#安装插件\" class=\"headerlink\" title=\"安装插件\"></a>安装插件</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yarn add moment -S</span><br></pre></td></tr></table></figure>\n<h3 id=\"导入使用\"><a href=\"#导入使用\" class=\"headerlink\" title=\"导入使用\"></a>导入使用</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import moment from &apos;moment&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">filters: &#123;</span><br><span class=\"line\">    dateyear(time)&#123;</span><br><span class=\"line\">        return moment(time*1000).format(&quot;YYYY年MM月DD日&quot;)</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    formatDate(time) &#123;</span><br><span class=\"line\">        return moment(time*1000).format(&quot;YYYY-MM-DD HH:mm:ss&quot;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n<p>filters过滤器，time时间戳的形参，time为什么要乘以1000？因为我公司的后端是PHP，PHP返回的时间戳需要乘以1000,格式化的时间才准确显示。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;template&gt;</span><br><span class=\"line\">    &lt;div&gt;&#123;&#123;item.add_time | formatDate&#125;&#125;&lt;/div&gt;</span><br><span class=\"line\">&lt;/template&gt;</span><br></pre></td></tr></table></figure></p>\n<p>在vue模版时间格式化的显示</p>"},{"title":"React","date":"2019-02-21T14:06:54.000Z","_content":"### React介绍\n<!-- more -->\n\n### 概述\n1. Fackbook开源的一个JavaScript库\n2. React结合生态库构成一个MVC框架\n3. React特点\n· Declarative(声明式编码)\n· Component-Based(组件化编码)\n    组件化、复用\n· 高效-高效的DOM Diff算法，最小化页面重绘\n    通过创建虚拟DOM的方式，不是直接操作DOM，而是通过构建JavaScript的语法，拼接DOM对象，一次性插入DOM\n· 单向数据流\n    Vue在输入框表单上是双向数据流。而React都是单向数据流，自上而下的数据传递，“从一棵树的根流向它的叶子”\n\n### 生态介绍\n· React + React-Router + Redux + Axios + Babel + Webpack\n\n### 编程式和声明式\n1. 编程式实现\n· 需要以具体代码表达在哪里(where)做什么(what),如何实现(how)\n2. 声明式实现\n· 只需要声明在哪里(where)做什么(what)，而无需关心如何实现(how)\n\n### 生命周期\n![image](/images/react.png)\n1. getDefaultProps\n· 初始化一个props属性，props来自父组件或其它组件传递过来的\n2. getInitalState\n· 组件的初始化状态\n3. componentWillMount()\n· 组件初始化之前调用这个方法，此时可以进行开启定时器、向服务器发送请求等操作\n4. render()\n· 组件渲染\n5. componentDidMount\n· 组件DOM插入完调用的方法，此时页面中有了真正的DOM的元素，可以进行DOM相关的操作\n6. componentWillReceiveProps()\n· 来自父组件传递属性调用的方法。组件接收到属性时触发\n7. shouldComonentUpdate()\n· 组件的更新，调用setState方法就会这个生命周期。组件的状态发生改变时触发\n8. componentWillUpdate()\n· 组件即将被更新时触发\n9. componentDidUpdate()\n· 组件被更新完成后触发。页面中产生了新的DOM的元素，可以进行DOM操作\n10. componentWillUnmount\n· 组件被销毁时触发。这里我们可以进行一些清理操作，例如清理定时器，取消Redux的订阅事件等等。\n\n\n\n\n\n","source":"_posts/react.md","raw":"---\ntitle: React\ndate: 2019-02-21 22:06:54\ntags: [\"React\"]\ncategories: React\n---\n### React介绍\n<!-- more -->\n\n### 概述\n1. Fackbook开源的一个JavaScript库\n2. React结合生态库构成一个MVC框架\n3. React特点\n· Declarative(声明式编码)\n· Component-Based(组件化编码)\n    组件化、复用\n· 高效-高效的DOM Diff算法，最小化页面重绘\n    通过创建虚拟DOM的方式，不是直接操作DOM，而是通过构建JavaScript的语法，拼接DOM对象，一次性插入DOM\n· 单向数据流\n    Vue在输入框表单上是双向数据流。而React都是单向数据流，自上而下的数据传递，“从一棵树的根流向它的叶子”\n\n### 生态介绍\n· React + React-Router + Redux + Axios + Babel + Webpack\n\n### 编程式和声明式\n1. 编程式实现\n· 需要以具体代码表达在哪里(where)做什么(what),如何实现(how)\n2. 声明式实现\n· 只需要声明在哪里(where)做什么(what)，而无需关心如何实现(how)\n\n### 生命周期\n![image](/images/react.png)\n1. getDefaultProps\n· 初始化一个props属性，props来自父组件或其它组件传递过来的\n2. getInitalState\n· 组件的初始化状态\n3. componentWillMount()\n· 组件初始化之前调用这个方法，此时可以进行开启定时器、向服务器发送请求等操作\n4. render()\n· 组件渲染\n5. componentDidMount\n· 组件DOM插入完调用的方法，此时页面中有了真正的DOM的元素，可以进行DOM相关的操作\n6. componentWillReceiveProps()\n· 来自父组件传递属性调用的方法。组件接收到属性时触发\n7. shouldComonentUpdate()\n· 组件的更新，调用setState方法就会这个生命周期。组件的状态发生改变时触发\n8. componentWillUpdate()\n· 组件即将被更新时触发\n9. componentDidUpdate()\n· 组件被更新完成后触发。页面中产生了新的DOM的元素，可以进行DOM操作\n10. componentWillUnmount\n· 组件被销毁时触发。这里我们可以进行一些清理操作，例如清理定时器，取消Redux的订阅事件等等。\n\n\n\n\n\n","slug":"react","published":1,"updated":"2019-03-31T14:27:33.175Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuowpbs8001jja6jy2ehhvr2","content":"<h3 id=\"React介绍\"><a href=\"#React介绍\" class=\"headerlink\" title=\"React介绍\"></a>React介绍</h3><a id=\"more\"></a>\n<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>Fackbook开源的一个JavaScript库</li>\n<li>React结合生态库构成一个MVC框架</li>\n<li>React特点<br>· Declarative(声明式编码)<br>· Component-Based(组件化编码)<br> 组件化、复用<br>· 高效-高效的DOM Diff算法，最小化页面重绘<br> 通过创建虚拟DOM的方式，不是直接操作DOM，而是通过构建JavaScript的语法，拼接DOM对象，一次性插入DOM<br>· 单向数据流<br> Vue在输入框表单上是双向数据流。而React都是单向数据流，自上而下的数据传递，“从一棵树的根流向它的叶子”</li>\n</ol>\n<h3 id=\"生态介绍\"><a href=\"#生态介绍\" class=\"headerlink\" title=\"生态介绍\"></a>生态介绍</h3><p>· React + React-Router + Redux + Axios + Babel + Webpack</p>\n<h3 id=\"编程式和声明式\"><a href=\"#编程式和声明式\" class=\"headerlink\" title=\"编程式和声明式\"></a>编程式和声明式</h3><ol>\n<li>编程式实现<br>· 需要以具体代码表达在哪里(where)做什么(what),如何实现(how)</li>\n<li>声明式实现<br>· 只需要声明在哪里(where)做什么(what)，而无需关心如何实现(how)</li>\n</ol>\n<h3 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h3><p><img src=\"/images/react.png\" alt=\"image\"></p>\n<ol>\n<li>getDefaultProps<br>· 初始化一个props属性，props来自父组件或其它组件传递过来的</li>\n<li>getInitalState<br>· 组件的初始化状态</li>\n<li>componentWillMount()<br>· 组件初始化之前调用这个方法，此时可以进行开启定时器、向服务器发送请求等操作</li>\n<li>render()<br>· 组件渲染</li>\n<li>componentDidMount<br>· 组件DOM插入完调用的方法，此时页面中有了真正的DOM的元素，可以进行DOM相关的操作</li>\n<li>componentWillReceiveProps()<br>· 来自父组件传递属性调用的方法。组件接收到属性时触发</li>\n<li>shouldComonentUpdate()<br>· 组件的更新，调用setState方法就会这个生命周期。组件的状态发生改变时触发</li>\n<li>componentWillUpdate()<br>· 组件即将被更新时触发</li>\n<li>componentDidUpdate()<br>· 组件被更新完成后触发。页面中产生了新的DOM的元素，可以进行DOM操作</li>\n<li>componentWillUnmount<br>· 组件被销毁时触发。这里我们可以进行一些清理操作，例如清理定时器，取消Redux的订阅事件等等。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<h3 id=\"React介绍\"><a href=\"#React介绍\" class=\"headerlink\" title=\"React介绍\"></a>React介绍</h3>","more":"<h3 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h3><ol>\n<li>Fackbook开源的一个JavaScript库</li>\n<li>React结合生态库构成一个MVC框架</li>\n<li>React特点<br>· Declarative(声明式编码)<br>· Component-Based(组件化编码)<br> 组件化、复用<br>· 高效-高效的DOM Diff算法，最小化页面重绘<br> 通过创建虚拟DOM的方式，不是直接操作DOM，而是通过构建JavaScript的语法，拼接DOM对象，一次性插入DOM<br>· 单向数据流<br> Vue在输入框表单上是双向数据流。而React都是单向数据流，自上而下的数据传递，“从一棵树的根流向它的叶子”</li>\n</ol>\n<h3 id=\"生态介绍\"><a href=\"#生态介绍\" class=\"headerlink\" title=\"生态介绍\"></a>生态介绍</h3><p>· React + React-Router + Redux + Axios + Babel + Webpack</p>\n<h3 id=\"编程式和声明式\"><a href=\"#编程式和声明式\" class=\"headerlink\" title=\"编程式和声明式\"></a>编程式和声明式</h3><ol>\n<li>编程式实现<br>· 需要以具体代码表达在哪里(where)做什么(what),如何实现(how)</li>\n<li>声明式实现<br>· 只需要声明在哪里(where)做什么(what)，而无需关心如何实现(how)</li>\n</ol>\n<h3 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h3><p><img src=\"/images/react.png\" alt=\"image\"></p>\n<ol>\n<li>getDefaultProps<br>· 初始化一个props属性，props来自父组件或其它组件传递过来的</li>\n<li>getInitalState<br>· 组件的初始化状态</li>\n<li>componentWillMount()<br>· 组件初始化之前调用这个方法，此时可以进行开启定时器、向服务器发送请求等操作</li>\n<li>render()<br>· 组件渲染</li>\n<li>componentDidMount<br>· 组件DOM插入完调用的方法，此时页面中有了真正的DOM的元素，可以进行DOM相关的操作</li>\n<li>componentWillReceiveProps()<br>· 来自父组件传递属性调用的方法。组件接收到属性时触发</li>\n<li>shouldComonentUpdate()<br>· 组件的更新，调用setState方法就会这个生命周期。组件的状态发生改变时触发</li>\n<li>componentWillUpdate()<br>· 组件即将被更新时触发</li>\n<li>componentDidUpdate()<br>· 组件被更新完成后触发。页面中产生了新的DOM的元素，可以进行DOM操作</li>\n<li>componentWillUnmount<br>· 组件被销毁时触发。这里我们可以进行一些清理操作，例如清理定时器，取消Redux的订阅事件等等。</li>\n</ol>"},{"title":"vue-router的history模式","date":"2018-10-15T16:00:00.000Z","_content":"\n### History模式\n<!-- more -->\n\n### 简述\n1.vue-router 默认 hash 模式 ,后面带有#号，如果不要hash，可以用路由的 history 模式，后面不带#号。\n\n2.前端处理\n```\nconst router = new VueRouter({\n  mode: 'history',\n  base:\"/app\"\n  routes: [...]\n})\n```\nbase：应用的基路径。例如，如果整个单页应用服务在 /app/ 下，然后 base 就应该设为 \"/app/\"。如果放在服务器app文件下面没有base设置，页面会出现空白，无法显示页面。\n\n3.history 模式需要后端的配置支持\n[后端配置history模式详情](https://router.vuejs.org/zh/guide/essentials/history-mode.html#%E5%90%8E%E7%AB%AF%E9%85%8D%E7%BD%AE%E4%BE%8B%E5%AD%90)\n\n","source":"_posts/vue-router-history.md","raw":"---\ntitle: vue-router的history模式\ndate: 2018-10-16\ntags: [\"vue-router\"]\ncategories: vue\n---\n\n### History模式\n<!-- more -->\n\n### 简述\n1.vue-router 默认 hash 模式 ,后面带有#号，如果不要hash，可以用路由的 history 模式，后面不带#号。\n\n2.前端处理\n```\nconst router = new VueRouter({\n  mode: 'history',\n  base:\"/app\"\n  routes: [...]\n})\n```\nbase：应用的基路径。例如，如果整个单页应用服务在 /app/ 下，然后 base 就应该设为 \"/app/\"。如果放在服务器app文件下面没有base设置，页面会出现空白，无法显示页面。\n\n3.history 模式需要后端的配置支持\n[后端配置history模式详情](https://router.vuejs.org/zh/guide/essentials/history-mode.html#%E5%90%8E%E7%AB%AF%E9%85%8D%E7%BD%AE%E4%BE%8B%E5%AD%90)\n\n","slug":"vue-router-history","published":1,"updated":"2018-10-16T14:24:00.013Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuowpbsa001oja6j9cod2vnw","content":"<h3 id=\"History模式\"><a href=\"#History模式\" class=\"headerlink\" title=\"History模式\"></a>History模式</h3><a id=\"more\"></a>\n<h3 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h3><p>1.vue-router 默认 hash 模式 ,后面带有#号，如果不要hash，可以用路由的 history 模式，后面不带#号。</p>\n<p>2.前端处理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const router = new VueRouter(&#123;</span><br><span class=\"line\">  mode: &apos;history&apos;,</span><br><span class=\"line\">  base:&quot;/app&quot;</span><br><span class=\"line\">  routes: [...]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>base：应用的基路径。例如，如果整个单页应用服务在 /app/ 下，然后 base 就应该设为 “/app/“。如果放在服务器app文件下面没有base设置，页面会出现空白，无法显示页面。</p>\n<p>3.history 模式需要后端的配置支持<br><a href=\"https://router.vuejs.org/zh/guide/essentials/history-mode.html#%E5%90%8E%E7%AB%AF%E9%85%8D%E7%BD%AE%E4%BE%8B%E5%AD%90\" target=\"_blank\" rel=\"noopener\">后端配置history模式详情</a></p>\n","site":{"data":{}},"excerpt":"<h3 id=\"History模式\"><a href=\"#History模式\" class=\"headerlink\" title=\"History模式\"></a>History模式</h3>","more":"<h3 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h3><p>1.vue-router 默认 hash 模式 ,后面带有#号，如果不要hash，可以用路由的 history 模式，后面不带#号。</p>\n<p>2.前端处理<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const router = new VueRouter(&#123;</span><br><span class=\"line\">  mode: &apos;history&apos;,</span><br><span class=\"line\">  base:&quot;/app&quot;</span><br><span class=\"line\">  routes: [...]</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<p>base：应用的基路径。例如，如果整个单页应用服务在 /app/ 下，然后 base 就应该设为 “/app/“。如果放在服务器app文件下面没有base设置，页面会出现空白，无法显示页面。</p>\n<p>3.history 模式需要后端的配置支持<br><a href=\"https://router.vuejs.org/zh/guide/essentials/history-mode.html#%E5%90%8E%E7%AB%AF%E9%85%8D%E7%BD%AE%E4%BE%8B%E5%AD%90\" target=\"_blank\" rel=\"noopener\">后端配置history模式详情</a></p>"},{"title":"Vuex","date":"2018-10-08T16:00:00.000Z","_content":"### Vuex的使用\n<!-- more -->\n\n### Vuex是什么\nVuex是vue的全局状态管理模式，为所有组件管理状态，当多组件共享状态时，应当使用vuex，数据更好进行管理。简单说就是无论父组件还是子组件或子子组件都可以直接从vuex获取状态，vuex提供统一状态管理，更好去管理数据。\n#### Vuex图解\n![image](/images/vuex.png)\n1.通过提交mutations去改变state状态，从而state状态渲染到视图组件上\n2.视图组件可以dispatch派发一个Action进行异步操作，异步操作在action里面，在action里面可以commit-mutation\n3.视图组件可以派发action去提交Mutations，从而改变state\n\n### State\n1.state是vuex唯一的状态源，用一个对象包含了全部的应用层级状态。\n```\nstate.js \n\nconst state = {\n    count:1\n}\nexport default state;\n```\n2.如何在vue组件获取vuex状态\n```\nconst Counter = {\n  template: `<div>{{ count }}</div>`,\n  computed: {\n    count () {\n      return this.$store.state.count\n    }\n  }\n}\n```\n通过在根实例注册store选项，注入到根组件的所有子组件，且子组件能通过 this.$store 访问到。通过计算属性返回某个状态，每当this.$store.state.count变化的时候，都会重新求取计算属性，计算属性有缓存。\n\n3.mapState辅助函数\n当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余，帮助我们生成计算属性，让你少按几次键\n```\nimport { mapState } from 'vuex'\nexport defauilt {\n    computed:{\n        ...mapState(\n            ['count']\n        )\n    }\n}\n```\n\n### Getter\n#### 简述\nVuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。\n```\ngetters.js\n\nexport const count = state => state.count\n```\n#### 访问方式\n1.组件中使用它\n```\ncomputed: {\n  doneTodosCount () {\n    return this.$store.getters.count\n  }\n}\n```\n2.mapGetters辅助函数，个人比较喜欢当一种方式\n使用对象展开运算符将 getter 混入 computed 对象中\n```\nimport { mapGetters } from 'vuex'\n\nexport default {\n  computed: { \n    ...mapGetters([\n      'count',\n      'anotherGetter',\n    ])\n  }\n}\n```\n如果你想将一个 getter 属性另取一个名字，使用对象形式：\n```\nmapGetters({\n  把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`\n  doneCount: 'doneTodosCount'\n})\n```\n\n### Mutation\n更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。个人比较常用的一种方式\n\n#### Mutation配置\n```\nmutations-types.js\n\nexport const SET_MUTATION = 'export const SET_MUTATION'\n\n```\n使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：\n\n```\nmutations.js\n\nimport * as types from './mutations-types.js'\n\nconst mutations = {\n  [types.SET_MUTATION](state,payload){\n\n  }\n}\n\nexport default mutations;\n```\nstate参数可以获取vuex中所有数据源，payload是提交mutations传入的数据参数。\n#### 提交mutation\n1.mapMutations辅助函数\n```\nimport { mapMutations } from 'vuex'\n\nmethods:{\n  test(){\n    this.mutation({\n      amount: 10\n    })\n  },\n  ...mapMutations({\n    mutation:'types.SET_MUTATION'\n  })\n}\n```\n将 `this.mutation()` 映射为 `this.$store.commit('increment')`。`this.mutation()`提交mutation。\n```\n接收payload\nmutations.js\n\nimport * as types from './mutations-types.js'\n\nconst mutations = {\n  [types.SET_MUTATION](state,payload){\n    state.count = payload.amount\n  }\n}\n\n```\n\n### Action\nAction 提交的是 mutation，而不是直接变更状态。Action 可以包含任意异步操作。\n#### 注册简单的action\n```\nimport * as types from './mutations-types.js'\n\nexport const actionFn = function({commit,state},{amount}){\n  commit(types.SET_MUTATION,amount)\n}\n\n```\n#### 在组件中分发 Action\n```\nimport { mapActions } from 'vuex'\n\nmethods:{\n  test(){\n    this.actionFn({amount:10})\n  },\n  ...mapActions([\n    'actionFn'\n  ])\n}\n```\n\n\n\n","source":"_posts/vue-vuex.md","raw":"---\ntitle: Vuex\ndate: 2018-10-09\ntags: [\"vuex\"]\ncategories: vue\n---\n### Vuex的使用\n<!-- more -->\n\n### Vuex是什么\nVuex是vue的全局状态管理模式，为所有组件管理状态，当多组件共享状态时，应当使用vuex，数据更好进行管理。简单说就是无论父组件还是子组件或子子组件都可以直接从vuex获取状态，vuex提供统一状态管理，更好去管理数据。\n#### Vuex图解\n![image](/images/vuex.png)\n1.通过提交mutations去改变state状态，从而state状态渲染到视图组件上\n2.视图组件可以dispatch派发一个Action进行异步操作，异步操作在action里面，在action里面可以commit-mutation\n3.视图组件可以派发action去提交Mutations，从而改变state\n\n### State\n1.state是vuex唯一的状态源，用一个对象包含了全部的应用层级状态。\n```\nstate.js \n\nconst state = {\n    count:1\n}\nexport default state;\n```\n2.如何在vue组件获取vuex状态\n```\nconst Counter = {\n  template: `<div>{{ count }}</div>`,\n  computed: {\n    count () {\n      return this.$store.state.count\n    }\n  }\n}\n```\n通过在根实例注册store选项，注入到根组件的所有子组件，且子组件能通过 this.$store 访问到。通过计算属性返回某个状态，每当this.$store.state.count变化的时候，都会重新求取计算属性，计算属性有缓存。\n\n3.mapState辅助函数\n当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余，帮助我们生成计算属性，让你少按几次键\n```\nimport { mapState } from 'vuex'\nexport defauilt {\n    computed:{\n        ...mapState(\n            ['count']\n        )\n    }\n}\n```\n\n### Getter\n#### 简述\nVuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。\n```\ngetters.js\n\nexport const count = state => state.count\n```\n#### 访问方式\n1.组件中使用它\n```\ncomputed: {\n  doneTodosCount () {\n    return this.$store.getters.count\n  }\n}\n```\n2.mapGetters辅助函数，个人比较喜欢当一种方式\n使用对象展开运算符将 getter 混入 computed 对象中\n```\nimport { mapGetters } from 'vuex'\n\nexport default {\n  computed: { \n    ...mapGetters([\n      'count',\n      'anotherGetter',\n    ])\n  }\n}\n```\n如果你想将一个 getter 属性另取一个名字，使用对象形式：\n```\nmapGetters({\n  把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`\n  doneCount: 'doneTodosCount'\n})\n```\n\n### Mutation\n更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。个人比较常用的一种方式\n\n#### Mutation配置\n```\nmutations-types.js\n\nexport const SET_MUTATION = 'export const SET_MUTATION'\n\n```\n使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：\n\n```\nmutations.js\n\nimport * as types from './mutations-types.js'\n\nconst mutations = {\n  [types.SET_MUTATION](state,payload){\n\n  }\n}\n\nexport default mutations;\n```\nstate参数可以获取vuex中所有数据源，payload是提交mutations传入的数据参数。\n#### 提交mutation\n1.mapMutations辅助函数\n```\nimport { mapMutations } from 'vuex'\n\nmethods:{\n  test(){\n    this.mutation({\n      amount: 10\n    })\n  },\n  ...mapMutations({\n    mutation:'types.SET_MUTATION'\n  })\n}\n```\n将 `this.mutation()` 映射为 `this.$store.commit('increment')`。`this.mutation()`提交mutation。\n```\n接收payload\nmutations.js\n\nimport * as types from './mutations-types.js'\n\nconst mutations = {\n  [types.SET_MUTATION](state,payload){\n    state.count = payload.amount\n  }\n}\n\n```\n\n### Action\nAction 提交的是 mutation，而不是直接变更状态。Action 可以包含任意异步操作。\n#### 注册简单的action\n```\nimport * as types from './mutations-types.js'\n\nexport const actionFn = function({commit,state},{amount}){\n  commit(types.SET_MUTATION,amount)\n}\n\n```\n#### 在组件中分发 Action\n```\nimport { mapActions } from 'vuex'\n\nmethods:{\n  test(){\n    this.actionFn({amount:10})\n  },\n  ...mapActions([\n    'actionFn'\n  ])\n}\n```\n\n\n\n","slug":"vue-vuex","published":1,"updated":"2018-10-09T15:02:29.600Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuowpbsb001rja6j4083eahe","content":"<h3 id=\"Vuex的使用\"><a href=\"#Vuex的使用\" class=\"headerlink\" title=\"Vuex的使用\"></a>Vuex的使用</h3><a id=\"more\"></a>\n<h3 id=\"Vuex是什么\"><a href=\"#Vuex是什么\" class=\"headerlink\" title=\"Vuex是什么\"></a>Vuex是什么</h3><p>Vuex是vue的全局状态管理模式，为所有组件管理状态，当多组件共享状态时，应当使用vuex，数据更好进行管理。简单说就是无论父组件还是子组件或子子组件都可以直接从vuex获取状态，vuex提供统一状态管理，更好去管理数据。</p>\n<h4 id=\"Vuex图解\"><a href=\"#Vuex图解\" class=\"headerlink\" title=\"Vuex图解\"></a>Vuex图解</h4><p><img src=\"/images/vuex.png\" alt=\"image\"><br>1.通过提交mutations去改变state状态，从而state状态渲染到视图组件上<br>2.视图组件可以dispatch派发一个Action进行异步操作，异步操作在action里面，在action里面可以commit-mutation<br>3.视图组件可以派发action去提交Mutations，从而改变state</p>\n<h3 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"State\"></a>State</h3><p>1.state是vuex唯一的状态源，用一个对象包含了全部的应用层级状态。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">state.js </span><br><span class=\"line\"></span><br><span class=\"line\">const state = &#123;</span><br><span class=\"line\">    count:1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default state;</span><br></pre></td></tr></table></figure></p>\n<p>2.如何在vue组件获取vuex状态<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const Counter = &#123;</span><br><span class=\"line\">  template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`,</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    count () &#123;</span><br><span class=\"line\">      return this.$store.state.count</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过在根实例注册store选项，注入到根组件的所有子组件，且子组件能通过 this.$store 访问到。通过计算属性返回某个状态，每当this.$store.state.count变化的时候，都会重新求取计算属性，计算属性有缓存。</p>\n<p>3.mapState辅助函数<br>当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余，帮助我们生成计算属性，让你少按几次键<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; mapState &#125; from &apos;vuex&apos;</span><br><span class=\"line\">export defauilt &#123;</span><br><span class=\"line\">    computed:&#123;</span><br><span class=\"line\">        ...mapState(</span><br><span class=\"line\">            [&apos;count&apos;]</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Getter\"><a href=\"#Getter\" class=\"headerlink\" title=\"Getter\"></a>Getter</h3><h4 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h4><p>Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getters.js</span><br><span class=\"line\"></span><br><span class=\"line\">export const count = state =&gt; state.count</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"访问方式\"><a href=\"#访问方式\" class=\"headerlink\" title=\"访问方式\"></a>访问方式</h4><p>1.组件中使用它<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: &#123;</span><br><span class=\"line\">  doneTodosCount () &#123;</span><br><span class=\"line\">    return this.$store.getters.count</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>2.mapGetters辅助函数，个人比较喜欢当一种方式<br>使用对象展开运算符将 getter 混入 computed 对象中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; mapGetters &#125; from &apos;vuex&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  computed: &#123; </span><br><span class=\"line\">    ...mapGetters([</span><br><span class=\"line\">      &apos;count&apos;,</span><br><span class=\"line\">      &apos;anotherGetter&apos;,</span><br><span class=\"line\">    ])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果你想将一个 getter 属性另取一个名字，使用对象形式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mapGetters(&#123;</span><br><span class=\"line\">  把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`</span><br><span class=\"line\">  doneCount: &apos;doneTodosCount&apos;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Mutation\"><a href=\"#Mutation\" class=\"headerlink\" title=\"Mutation\"></a>Mutation</h3><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。个人比较常用的一种方式</p>\n<h4 id=\"Mutation配置\"><a href=\"#Mutation配置\" class=\"headerlink\" title=\"Mutation配置\"></a>Mutation配置</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mutations-types.js</span><br><span class=\"line\"></span><br><span class=\"line\">export const SET_MUTATION = &apos;export const SET_MUTATION&apos;</span><br></pre></td></tr></table></figure>\n<p>使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mutations.js</span><br><span class=\"line\"></span><br><span class=\"line\">import * as types from &apos;./mutations-types.js&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">const mutations = &#123;</span><br><span class=\"line\">  [types.SET_MUTATION](state,payload)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default mutations;</span><br></pre></td></tr></table></figure>\n<p>state参数可以获取vuex中所有数据源，payload是提交mutations传入的数据参数。</p>\n<h4 id=\"提交mutation\"><a href=\"#提交mutation\" class=\"headerlink\" title=\"提交mutation\"></a>提交mutation</h4><p>1.mapMutations辅助函数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; mapMutations &#125; from &apos;vuex&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">methods:&#123;</span><br><span class=\"line\">  test()&#123;</span><br><span class=\"line\">    this.mutation(&#123;</span><br><span class=\"line\">      amount: 10</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  ...mapMutations(&#123;</span><br><span class=\"line\">    mutation:&apos;types.SET_MUTATION&apos;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>将 <code>this.mutation()</code> 映射为 <code>this.$store.commit(&#39;increment&#39;)</code>。<code>this.mutation()</code>提交mutation。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">接收payload</span><br><span class=\"line\">mutations.js</span><br><span class=\"line\"></span><br><span class=\"line\">import * as types from &apos;./mutations-types.js&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">const mutations = &#123;</span><br><span class=\"line\">  [types.SET_MUTATION](state,payload)&#123;</span><br><span class=\"line\">    state.count = payload.amount</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Action\"><a href=\"#Action\" class=\"headerlink\" title=\"Action\"></a>Action</h3><p>Action 提交的是 mutation，而不是直接变更状态。Action 可以包含任意异步操作。</p>\n<h4 id=\"注册简单的action\"><a href=\"#注册简单的action\" class=\"headerlink\" title=\"注册简单的action\"></a>注册简单的action</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import * as types from &apos;./mutations-types.js&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">export const actionFn = function(&#123;commit,state&#125;,&#123;amount&#125;)&#123;</span><br><span class=\"line\">  commit(types.SET_MUTATION,amount)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在组件中分发-Action\"><a href=\"#在组件中分发-Action\" class=\"headerlink\" title=\"在组件中分发 Action\"></a>在组件中分发 Action</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; mapActions &#125; from &apos;vuex&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">methods:&#123;</span><br><span class=\"line\">  test()&#123;</span><br><span class=\"line\">    this.actionFn(&#123;amount:10&#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  ...mapActions([</span><br><span class=\"line\">    &apos;actionFn&apos;</span><br><span class=\"line\">  ])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h3 id=\"Vuex的使用\"><a href=\"#Vuex的使用\" class=\"headerlink\" title=\"Vuex的使用\"></a>Vuex的使用</h3>","more":"<h3 id=\"Vuex是什么\"><a href=\"#Vuex是什么\" class=\"headerlink\" title=\"Vuex是什么\"></a>Vuex是什么</h3><p>Vuex是vue的全局状态管理模式，为所有组件管理状态，当多组件共享状态时，应当使用vuex，数据更好进行管理。简单说就是无论父组件还是子组件或子子组件都可以直接从vuex获取状态，vuex提供统一状态管理，更好去管理数据。</p>\n<h4 id=\"Vuex图解\"><a href=\"#Vuex图解\" class=\"headerlink\" title=\"Vuex图解\"></a>Vuex图解</h4><p><img src=\"/images/vuex.png\" alt=\"image\"><br>1.通过提交mutations去改变state状态，从而state状态渲染到视图组件上<br>2.视图组件可以dispatch派发一个Action进行异步操作，异步操作在action里面，在action里面可以commit-mutation<br>3.视图组件可以派发action去提交Mutations，从而改变state</p>\n<h3 id=\"State\"><a href=\"#State\" class=\"headerlink\" title=\"State\"></a>State</h3><p>1.state是vuex唯一的状态源，用一个对象包含了全部的应用层级状态。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">state.js </span><br><span class=\"line\"></span><br><span class=\"line\">const state = &#123;</span><br><span class=\"line\">    count:1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default state;</span><br></pre></td></tr></table></figure></p>\n<p>2.如何在vue组件获取vuex状态<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const Counter = &#123;</span><br><span class=\"line\">  template: `&lt;div&gt;&#123;&#123; count &#125;&#125;&lt;/div&gt;`,</span><br><span class=\"line\">  computed: &#123;</span><br><span class=\"line\">    count () &#123;</span><br><span class=\"line\">      return this.$store.state.count</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>通过在根实例注册store选项，注入到根组件的所有子组件，且子组件能通过 this.$store 访问到。通过计算属性返回某个状态，每当this.$store.state.count变化的时候，都会重新求取计算属性，计算属性有缓存。</p>\n<p>3.mapState辅助函数<br>当一个组件需要获取多个状态时候，将这些状态都声明为计算属性会有些重复和冗余，帮助我们生成计算属性，让你少按几次键<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; mapState &#125; from &apos;vuex&apos;</span><br><span class=\"line\">export defauilt &#123;</span><br><span class=\"line\">    computed:&#123;</span><br><span class=\"line\">        ...mapState(</span><br><span class=\"line\">            [&apos;count&apos;]</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Getter\"><a href=\"#Getter\" class=\"headerlink\" title=\"Getter\"></a>Getter</h3><h4 id=\"简述\"><a href=\"#简述\" class=\"headerlink\" title=\"简述\"></a>简述</h4><p>Vuex 允许我们在 store 中定义“getter”（可以认为是 store 的计算属性）。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getters.js</span><br><span class=\"line\"></span><br><span class=\"line\">export const count = state =&gt; state.count</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"访问方式\"><a href=\"#访问方式\" class=\"headerlink\" title=\"访问方式\"></a>访问方式</h4><p>1.组件中使用它<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">computed: &#123;</span><br><span class=\"line\">  doneTodosCount () &#123;</span><br><span class=\"line\">    return this.$store.getters.count</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>2.mapGetters辅助函数，个人比较喜欢当一种方式<br>使用对象展开运算符将 getter 混入 computed 对象中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; mapGetters &#125; from &apos;vuex&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">  computed: &#123; </span><br><span class=\"line\">    ...mapGetters([</span><br><span class=\"line\">      &apos;count&apos;,</span><br><span class=\"line\">      &apos;anotherGetter&apos;,</span><br><span class=\"line\">    ])</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如果你想将一个 getter 属性另取一个名字，使用对象形式：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mapGetters(&#123;</span><br><span class=\"line\">  把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`</span><br><span class=\"line\">  doneCount: &apos;doneTodosCount&apos;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Mutation\"><a href=\"#Mutation\" class=\"headerlink\" title=\"Mutation\"></a>Mutation</h3><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。个人比较常用的一种方式</p>\n<h4 id=\"Mutation配置\"><a href=\"#Mutation配置\" class=\"headerlink\" title=\"Mutation配置\"></a>Mutation配置</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mutations-types.js</span><br><span class=\"line\"></span><br><span class=\"line\">export const SET_MUTATION = &apos;export const SET_MUTATION&apos;</span><br></pre></td></tr></table></figure>\n<p>使用常量替代 mutation 事件类型在各种 Flux 实现中是很常见的模式。这样可以使 linter 之类的工具发挥作用，同时把这些常量放在单独的文件中可以让你的代码合作者对整个 app 包含的 mutation 一目了然：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mutations.js</span><br><span class=\"line\"></span><br><span class=\"line\">import * as types from &apos;./mutations-types.js&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">const mutations = &#123;</span><br><span class=\"line\">  [types.SET_MUTATION](state,payload)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export default mutations;</span><br></pre></td></tr></table></figure>\n<p>state参数可以获取vuex中所有数据源，payload是提交mutations传入的数据参数。</p>\n<h4 id=\"提交mutation\"><a href=\"#提交mutation\" class=\"headerlink\" title=\"提交mutation\"></a>提交mutation</h4><p>1.mapMutations辅助函数<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; mapMutations &#125; from &apos;vuex&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">methods:&#123;</span><br><span class=\"line\">  test()&#123;</span><br><span class=\"line\">    this.mutation(&#123;</span><br><span class=\"line\">      amount: 10</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  ...mapMutations(&#123;</span><br><span class=\"line\">    mutation:&apos;types.SET_MUTATION&apos;</span><br><span class=\"line\">  &#125;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>将 <code>this.mutation()</code> 映射为 <code>this.$store.commit(&#39;increment&#39;)</code>。<code>this.mutation()</code>提交mutation。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">接收payload</span><br><span class=\"line\">mutations.js</span><br><span class=\"line\"></span><br><span class=\"line\">import * as types from &apos;./mutations-types.js&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">const mutations = &#123;</span><br><span class=\"line\">  [types.SET_MUTATION](state,payload)&#123;</span><br><span class=\"line\">    state.count = payload.amount</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Action\"><a href=\"#Action\" class=\"headerlink\" title=\"Action\"></a>Action</h3><p>Action 提交的是 mutation，而不是直接变更状态。Action 可以包含任意异步操作。</p>\n<h4 id=\"注册简单的action\"><a href=\"#注册简单的action\" class=\"headerlink\" title=\"注册简单的action\"></a>注册简单的action</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import * as types from &apos;./mutations-types.js&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">export const actionFn = function(&#123;commit,state&#125;,&#123;amount&#125;)&#123;</span><br><span class=\"line\">  commit(types.SET_MUTATION,amount)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"在组件中分发-Action\"><a href=\"#在组件中分发-Action\" class=\"headerlink\" title=\"在组件中分发 Action\"></a>在组件中分发 Action</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123; mapActions &#125; from &apos;vuex&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">methods:&#123;</span><br><span class=\"line\">  test()&#123;</span><br><span class=\"line\">    this.actionFn(&#123;amount:10&#125;)</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  ...mapActions([</span><br><span class=\"line\">    &apos;actionFn&apos;</span><br><span class=\"line\">  ])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"小程序组件","date":"2018-11-03T16:00:00.000Z","_content":"\n### 小程序组件、事件与属性\n<!-- more -->\n\n### 组件引用\n```\nComponent({\n    /**\n    * 组件的属性列表，外部暴露的属性\n    */\n    properties: {\n        like:{\n            type:Number、String、Boolean, //属性的类型，必填\n            value:false, //初始值，选填\n            observer: function (newVal, oldVal) { \n                this.setData({\n                    val:newVal\n                })\n            } \n            // observer属性被改变时执行的函数（可选)，不要直接去改变properties的值(发生内存泄漏)，通过data定义的数据，通过setData把properties的值赋值data定义的值\n        }\n    },\n\n    /**\n    * 组件的初始数据\n    */\n    data: {\n        isLike:false,\n        val:null\n    },\n\n    /**\n    * 组件的方法列表\n    */\n    methods: {\n        this.properties.like//访问properties的属性\n    }\n})\n```\n1.微信开发者工具小程序新建Component,新建组件目录\n2.properties：对外属性，即如果外部的wxml文件传入数据时，会把数据设置成properties的属性。(类似vue父子组件的传值类型限定)\n3.data数据的状态绑定\n4.methods组件的方法和生命周期的使用\n5.只有setData才可以更新data的数据","source":"_posts/weChat-component.md","raw":"---\ntitle: 小程序组件\ndate: 2018-11-04\ntags: ['小程序']\ncategories: 小程序\n---\n\n### 小程序组件、事件与属性\n<!-- more -->\n\n### 组件引用\n```\nComponent({\n    /**\n    * 组件的属性列表，外部暴露的属性\n    */\n    properties: {\n        like:{\n            type:Number、String、Boolean, //属性的类型，必填\n            value:false, //初始值，选填\n            observer: function (newVal, oldVal) { \n                this.setData({\n                    val:newVal\n                })\n            } \n            // observer属性被改变时执行的函数（可选)，不要直接去改变properties的值(发生内存泄漏)，通过data定义的数据，通过setData把properties的值赋值data定义的值\n        }\n    },\n\n    /**\n    * 组件的初始数据\n    */\n    data: {\n        isLike:false,\n        val:null\n    },\n\n    /**\n    * 组件的方法列表\n    */\n    methods: {\n        this.properties.like//访问properties的属性\n    }\n})\n```\n1.微信开发者工具小程序新建Component,新建组件目录\n2.properties：对外属性，即如果外部的wxml文件传入数据时，会把数据设置成properties的属性。(类似vue父子组件的传值类型限定)\n3.data数据的状态绑定\n4.methods组件的方法和生命周期的使用\n5.只有setData才可以更新data的数据","slug":"weChat-component","published":1,"updated":"2018-11-04T15:00:22.487Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuowpbsd001vja6j24ehzvgs","content":"<h3 id=\"小程序组件、事件与属性\"><a href=\"#小程序组件、事件与属性\" class=\"headerlink\" title=\"小程序组件、事件与属性\"></a>小程序组件、事件与属性</h3><a id=\"more\"></a>\n<h3 id=\"组件引用\"><a href=\"#组件引用\" class=\"headerlink\" title=\"组件引用\"></a>组件引用</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Component(&#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">    * 组件的属性列表，外部暴露的属性</span><br><span class=\"line\">    */</span><br><span class=\"line\">    properties: &#123;</span><br><span class=\"line\">        like:&#123;</span><br><span class=\"line\">            type:Number、String、Boolean, //属性的类型，必填</span><br><span class=\"line\">            value:false, //初始值，选填</span><br><span class=\"line\">            observer: function (newVal, oldVal) &#123; </span><br><span class=\"line\">                this.setData(&#123;</span><br><span class=\"line\">                    val:newVal</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">            // observer属性被改变时执行的函数（可选)，不要直接去改变properties的值(发生内存泄漏)，通过data定义的数据，通过setData把properties的值赋值data定义的值</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">    * 组件的初始数据</span><br><span class=\"line\">    */</span><br><span class=\"line\">    data: &#123;</span><br><span class=\"line\">        isLike:false,</span><br><span class=\"line\">        val:null</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">    * 组件的方法列表</span><br><span class=\"line\">    */</span><br><span class=\"line\">    methods: &#123;</span><br><span class=\"line\">        this.properties.like//访问properties的属性</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>1.微信开发者工具小程序新建Component,新建组件目录<br>2.properties：对外属性，即如果外部的wxml文件传入数据时，会把数据设置成properties的属性。(类似vue父子组件的传值类型限定)<br>3.data数据的状态绑定<br>4.methods组件的方法和生命周期的使用<br>5.只有setData才可以更新data的数据</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"小程序组件、事件与属性\"><a href=\"#小程序组件、事件与属性\" class=\"headerlink\" title=\"小程序组件、事件与属性\"></a>小程序组件、事件与属性</h3>","more":"<h3 id=\"组件引用\"><a href=\"#组件引用\" class=\"headerlink\" title=\"组件引用\"></a>组件引用</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Component(&#123;</span><br><span class=\"line\">    /**</span><br><span class=\"line\">    * 组件的属性列表，外部暴露的属性</span><br><span class=\"line\">    */</span><br><span class=\"line\">    properties: &#123;</span><br><span class=\"line\">        like:&#123;</span><br><span class=\"line\">            type:Number、String、Boolean, //属性的类型，必填</span><br><span class=\"line\">            value:false, //初始值，选填</span><br><span class=\"line\">            observer: function (newVal, oldVal) &#123; </span><br><span class=\"line\">                this.setData(&#123;</span><br><span class=\"line\">                    val:newVal</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125; </span><br><span class=\"line\">            // observer属性被改变时执行的函数（可选)，不要直接去改变properties的值(发生内存泄漏)，通过data定义的数据，通过setData把properties的值赋值data定义的值</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">    * 组件的初始数据</span><br><span class=\"line\">    */</span><br><span class=\"line\">    data: &#123;</span><br><span class=\"line\">        isLike:false,</span><br><span class=\"line\">        val:null</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\"></span><br><span class=\"line\">    /**</span><br><span class=\"line\">    * 组件的方法列表</span><br><span class=\"line\">    */</span><br><span class=\"line\">    methods: &#123;</span><br><span class=\"line\">        this.properties.like//访问properties的属性</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>1.微信开发者工具小程序新建Component,新建组件目录<br>2.properties：对外属性，即如果外部的wxml文件传入数据时，会把数据设置成properties的属性。(类似vue父子组件的传值类型限定)<br>3.data数据的状态绑定<br>4.methods组件的方法和生命周期的使用<br>5.只有setData才可以更新data的数据</p>"},{"title":"小程序http封装","date":"2018-12-04T16:00:00.000Z","_content":"\n### 小程序wx.request请求封装\n<!-- more -->\n\n``` \nconfig.js\n---\napi_base_url:接口域名\nappkey:头部携带的参数\nconst config = {\n    api_base_url: '',\n    appkey: \"\",\n}\n\nexport {config }\n```\n```\nhttp.js\n---\n\nimport {config} from '../config.js'\n\n定义状态码返回的错误信息 \nconst tips = {\n    1: '抱歉，出现了一个错误',\n    1005:'appkey无效，请前往www.7yue.pro申请',\n    3000:'期刊不存在'\n}\n\n解构\nclass HTTP{\n    默认GET请求方式，返回Promise\n    request({url,data={},method='GET'}){\n        return new Promise((resolve, reject)=>{\n            this._request(url,resolve,reject,data, method)\n        })\n    }\n    _request(url,resolve, reject, data={}, method='GET'){\n        wx.request({\n            url:config.api_base_url + url,\n            method:method,\n            data:data,\n            header:{\n                'content-type':'application/json',\n                'appkey':config.appkey\n            },\n            success:(res)=>{\n                const code = res.statusCode.toString()\n                if (code.startsWith('2')){\n                    resolve(res.data)\n                }\n                else{\n                    reject()\n                    const error_code = res.data.error_code\n                    this._show_error(error_code)\n                }\n            },\n            fail:(err)=>{\n                reject()\n                this._show_error(1)\n            }\n        })\n\n    }\n\n    _show_error(error_code){\n        if(!error_code){\n            error_code = 1\n        }\n        const tip = tips[error_code]\n        wx.showToast({\n            title: tip?tip:tips[1], \n            icon:'none',\n            duration:2000\n        }) \n    }\n\n\n}\n\nexport {HTTP}\n```\n\n\n```\nmodel.js\n---\nimport {\n    HTTP\n}\nfrom 'http.js'\n\nES6继承\nclass Model extends HTTP {\n\n    GET请求\n    getDetail(bid) {\n        return this.request({\n            url: `book/${bid}/detail`\n        })\n    }\n\n    POST请求\n    postComment(bid, comment) {\n        return this.request({\n            url: 'book/add/short_comment',\n            method: 'POST',\n            data: {\n                book_id: bid,\n                content: comment\n            }\n        })\n    }\n}\n```\n\n```\n使用\n---\nimport {\n  Models\n} from '/models.js'\n\n实例化对象\nconst model = new Models()\n\nmodel.getDetail().then(res => {\n\n})\n```","source":"_posts/weChat-wx-request.md","raw":"---\ntitle: 小程序http封装\ndate: 2018-12-05\ntags: ['小程序']\ncategories: 小程序\n---\n\n### 小程序wx.request请求封装\n<!-- more -->\n\n``` \nconfig.js\n---\napi_base_url:接口域名\nappkey:头部携带的参数\nconst config = {\n    api_base_url: '',\n    appkey: \"\",\n}\n\nexport {config }\n```\n```\nhttp.js\n---\n\nimport {config} from '../config.js'\n\n定义状态码返回的错误信息 \nconst tips = {\n    1: '抱歉，出现了一个错误',\n    1005:'appkey无效，请前往www.7yue.pro申请',\n    3000:'期刊不存在'\n}\n\n解构\nclass HTTP{\n    默认GET请求方式，返回Promise\n    request({url,data={},method='GET'}){\n        return new Promise((resolve, reject)=>{\n            this._request(url,resolve,reject,data, method)\n        })\n    }\n    _request(url,resolve, reject, data={}, method='GET'){\n        wx.request({\n            url:config.api_base_url + url,\n            method:method,\n            data:data,\n            header:{\n                'content-type':'application/json',\n                'appkey':config.appkey\n            },\n            success:(res)=>{\n                const code = res.statusCode.toString()\n                if (code.startsWith('2')){\n                    resolve(res.data)\n                }\n                else{\n                    reject()\n                    const error_code = res.data.error_code\n                    this._show_error(error_code)\n                }\n            },\n            fail:(err)=>{\n                reject()\n                this._show_error(1)\n            }\n        })\n\n    }\n\n    _show_error(error_code){\n        if(!error_code){\n            error_code = 1\n        }\n        const tip = tips[error_code]\n        wx.showToast({\n            title: tip?tip:tips[1], \n            icon:'none',\n            duration:2000\n        }) \n    }\n\n\n}\n\nexport {HTTP}\n```\n\n\n```\nmodel.js\n---\nimport {\n    HTTP\n}\nfrom 'http.js'\n\nES6继承\nclass Model extends HTTP {\n\n    GET请求\n    getDetail(bid) {\n        return this.request({\n            url: `book/${bid}/detail`\n        })\n    }\n\n    POST请求\n    postComment(bid, comment) {\n        return this.request({\n            url: 'book/add/short_comment',\n            method: 'POST',\n            data: {\n                book_id: bid,\n                content: comment\n            }\n        })\n    }\n}\n```\n\n```\n使用\n---\nimport {\n  Models\n} from '/models.js'\n\n实例化对象\nconst model = new Models()\n\nmodel.getDetail().then(res => {\n\n})\n```","slug":"weChat-wx-request","published":1,"updated":"2018-12-05T14:37:16.678Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjuowpbse001yja6jjqs6qtvs","content":"<h3 id=\"小程序wx-request请求封装\"><a href=\"#小程序wx-request请求封装\" class=\"headerlink\" title=\"小程序wx.request请求封装\"></a>小程序wx.request请求封装</h3><a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config.js</span><br><span class=\"line\">---</span><br><span class=\"line\">api_base_url:接口域名</span><br><span class=\"line\">appkey:头部携带的参数</span><br><span class=\"line\">const config = &#123;</span><br><span class=\"line\">    api_base_url: &apos;&apos;,</span><br><span class=\"line\">    appkey: &quot;&quot;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export &#123;config &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http.js</span><br><span class=\"line\">---</span><br><span class=\"line\"></span><br><span class=\"line\">import &#123;config&#125; from &apos;../config.js&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">定义状态码返回的错误信息 </span><br><span class=\"line\">const tips = &#123;</span><br><span class=\"line\">    1: &apos;抱歉，出现了一个错误&apos;,</span><br><span class=\"line\">    1005:&apos;appkey无效，请前往www.7yue.pro申请&apos;,</span><br><span class=\"line\">    3000:&apos;期刊不存在&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">解构</span><br><span class=\"line\">class HTTP&#123;</span><br><span class=\"line\">    默认GET请求方式，返回Promise</span><br><span class=\"line\">    request(&#123;url,data=&#123;&#125;,method=&apos;GET&apos;&#125;)&#123;</span><br><span class=\"line\">        return new Promise((resolve, reject)=&gt;&#123;</span><br><span class=\"line\">            this._request(url,resolve,reject,data, method)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _request(url,resolve, reject, data=&#123;&#125;, method=&apos;GET&apos;)&#123;</span><br><span class=\"line\">        wx.request(&#123;</span><br><span class=\"line\">            url:config.api_base_url + url,</span><br><span class=\"line\">            method:method,</span><br><span class=\"line\">            data:data,</span><br><span class=\"line\">            header:&#123;</span><br><span class=\"line\">                &apos;content-type&apos;:&apos;application/json&apos;,</span><br><span class=\"line\">                &apos;appkey&apos;:config.appkey</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            success:(res)=&gt;&#123;</span><br><span class=\"line\">                const code = res.statusCode.toString()</span><br><span class=\"line\">                if (code.startsWith(&apos;2&apos;))&#123;</span><br><span class=\"line\">                    resolve(res.data)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                else&#123;</span><br><span class=\"line\">                    reject()</span><br><span class=\"line\">                    const error_code = res.data.error_code</span><br><span class=\"line\">                    this._show_error(error_code)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            fail:(err)=&gt;&#123;</span><br><span class=\"line\">                reject()</span><br><span class=\"line\">                this._show_error(1)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    _show_error(error_code)&#123;</span><br><span class=\"line\">        if(!error_code)&#123;</span><br><span class=\"line\">            error_code = 1</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        const tip = tips[error_code]</span><br><span class=\"line\">        wx.showToast(&#123;</span><br><span class=\"line\">            title: tip?tip:tips[1], </span><br><span class=\"line\">            icon:&apos;none&apos;,</span><br><span class=\"line\">            duration:2000</span><br><span class=\"line\">        &#125;) </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export &#123;HTTP&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">model.js</span><br><span class=\"line\">---</span><br><span class=\"line\">import &#123;</span><br><span class=\"line\">    HTTP</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">from &apos;http.js&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">ES6继承</span><br><span class=\"line\">class Model extends HTTP &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    GET请求</span><br><span class=\"line\">    getDetail(bid) &#123;</span><br><span class=\"line\">        return this.request(&#123;</span><br><span class=\"line\">            url: `book/$&#123;bid&#125;/detail`</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    POST请求</span><br><span class=\"line\">    postComment(bid, comment) &#123;</span><br><span class=\"line\">        return this.request(&#123;</span><br><span class=\"line\">            url: &apos;book/add/short_comment&apos;,</span><br><span class=\"line\">            method: &apos;POST&apos;,</span><br><span class=\"line\">            data: &#123;</span><br><span class=\"line\">                book_id: bid,</span><br><span class=\"line\">                content: comment</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用</span><br><span class=\"line\">---</span><br><span class=\"line\">import &#123;</span><br><span class=\"line\">  Models</span><br><span class=\"line\">&#125; from &apos;/models.js&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">实例化对象</span><br><span class=\"line\">const model = new Models()</span><br><span class=\"line\"></span><br><span class=\"line\">model.getDetail().then(res =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<h3 id=\"小程序wx-request请求封装\"><a href=\"#小程序wx-request请求封装\" class=\"headerlink\" title=\"小程序wx.request请求封装\"></a>小程序wx.request请求封装</h3>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">config.js</span><br><span class=\"line\">---</span><br><span class=\"line\">api_base_url:接口域名</span><br><span class=\"line\">appkey:头部携带的参数</span><br><span class=\"line\">const config = &#123;</span><br><span class=\"line\">    api_base_url: &apos;&apos;,</span><br><span class=\"line\">    appkey: &quot;&quot;,</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export &#123;config &#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">http.js</span><br><span class=\"line\">---</span><br><span class=\"line\"></span><br><span class=\"line\">import &#123;config&#125; from &apos;../config.js&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">定义状态码返回的错误信息 </span><br><span class=\"line\">const tips = &#123;</span><br><span class=\"line\">    1: &apos;抱歉，出现了一个错误&apos;,</span><br><span class=\"line\">    1005:&apos;appkey无效，请前往www.7yue.pro申请&apos;,</span><br><span class=\"line\">    3000:&apos;期刊不存在&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">解构</span><br><span class=\"line\">class HTTP&#123;</span><br><span class=\"line\">    默认GET请求方式，返回Promise</span><br><span class=\"line\">    request(&#123;url,data=&#123;&#125;,method=&apos;GET&apos;&#125;)&#123;</span><br><span class=\"line\">        return new Promise((resolve, reject)=&gt;&#123;</span><br><span class=\"line\">            this._request(url,resolve,reject,data, method)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    _request(url,resolve, reject, data=&#123;&#125;, method=&apos;GET&apos;)&#123;</span><br><span class=\"line\">        wx.request(&#123;</span><br><span class=\"line\">            url:config.api_base_url + url,</span><br><span class=\"line\">            method:method,</span><br><span class=\"line\">            data:data,</span><br><span class=\"line\">            header:&#123;</span><br><span class=\"line\">                &apos;content-type&apos;:&apos;application/json&apos;,</span><br><span class=\"line\">                &apos;appkey&apos;:config.appkey</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            success:(res)=&gt;&#123;</span><br><span class=\"line\">                const code = res.statusCode.toString()</span><br><span class=\"line\">                if (code.startsWith(&apos;2&apos;))&#123;</span><br><span class=\"line\">                    resolve(res.data)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                else&#123;</span><br><span class=\"line\">                    reject()</span><br><span class=\"line\">                    const error_code = res.data.error_code</span><br><span class=\"line\">                    this._show_error(error_code)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            fail:(err)=&gt;&#123;</span><br><span class=\"line\">                reject()</span><br><span class=\"line\">                this._show_error(1)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    _show_error(error_code)&#123;</span><br><span class=\"line\">        if(!error_code)&#123;</span><br><span class=\"line\">            error_code = 1</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        const tip = tips[error_code]</span><br><span class=\"line\">        wx.showToast(&#123;</span><br><span class=\"line\">            title: tip?tip:tips[1], </span><br><span class=\"line\">            icon:&apos;none&apos;,</span><br><span class=\"line\">            duration:2000</span><br><span class=\"line\">        &#125;) </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">export &#123;HTTP&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">model.js</span><br><span class=\"line\">---</span><br><span class=\"line\">import &#123;</span><br><span class=\"line\">    HTTP</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">from &apos;http.js&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">ES6继承</span><br><span class=\"line\">class Model extends HTTP &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    GET请求</span><br><span class=\"line\">    getDetail(bid) &#123;</span><br><span class=\"line\">        return this.request(&#123;</span><br><span class=\"line\">            url: `book/$&#123;bid&#125;/detail`</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    POST请求</span><br><span class=\"line\">    postComment(bid, comment) &#123;</span><br><span class=\"line\">        return this.request(&#123;</span><br><span class=\"line\">            url: &apos;book/add/short_comment&apos;,</span><br><span class=\"line\">            method: &apos;POST&apos;,</span><br><span class=\"line\">            data: &#123;</span><br><span class=\"line\">                book_id: bid,</span><br><span class=\"line\">                content: comment</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">使用</span><br><span class=\"line\">---</span><br><span class=\"line\">import &#123;</span><br><span class=\"line\">  Models</span><br><span class=\"line\">&#125; from &apos;/models.js&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">实例化对象</span><br><span class=\"line\">const model = new Models()</span><br><span class=\"line\"></span><br><span class=\"line\">model.getDetail().then(res =&gt; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjuowpbrf0007ja6jkmn1pmpo","category_id":"cjuowpbrb0004ja6jc2a10zah","_id":"cjuowpbrp000fja6jxg01huw9"},{"post_id":"cjuowpbr50001ja6j6fy7yz6h","category_id":"cjuowpbrb0004ja6jc2a10zah","_id":"cjuowpbrq000kja6jqaf3zm6u"},{"post_id":"cjuowpbrk000cja6jksjy6ihu","category_id":"cjuowpbrb0004ja6jc2a10zah","_id":"cjuowpbrs000nja6j19ih701v"},{"post_id":"cjuowpbra0003ja6jxwls6gvt","category_id":"cjuowpbrh0009ja6jk9r1ra4i","_id":"cjuowpbrv000sja6j322mxb87"},{"post_id":"cjuowpbrn000eja6j6lqy358e","category_id":"cjuowpbrh0009ja6jk9r1ra4i","_id":"cjuowpbrx000vja6jtgpv0k1n"},{"post_id":"cjuowpbrq000jja6j1rtqa0cp","category_id":"cjuowpbrh0009ja6jk9r1ra4i","_id":"cjuowpbry0010ja6j3klmm3l6"},{"post_id":"cjuowpbre0006ja6jvniwrhsw","category_id":"cjuowpbrp000gja6jdxddminm","_id":"cjuowpbs40013ja6j8u6wz3yd"},{"post_id":"cjuowpbrg0008ja6jkawymq64","category_id":"cjuowpbrh0009ja6jk9r1ra4i","_id":"cjuowpbs50017ja6jf7nzrmwk"},{"post_id":"cjuowpbrr000mja6jh80c124t","category_id":"cjuowpbrx000wja6jegoh5jmz","_id":"cjuowpbs6001bja6j5awr811u"},{"post_id":"cjuowpbs30012ja6j0hngohmo","category_id":"cjuowpbrx000wja6jegoh5jmz","_id":"cjuowpbs7001gja6jj4t9hbng"},{"post_id":"cjuowpbs50019ja6jjfkf8ne3","category_id":"cjuowpbrx000wja6jegoh5jmz","_id":"cjuowpbs9001kja6jsd9msux7"},{"post_id":"cjuowpbru000rja6jf9zi0qgi","category_id":"cjuowpbs40014ja6jplwzm5ur","_id":"cjuowpbsb001pja6jx2tjde32"},{"post_id":"cjuowpbs8001hja6j80y5ojg4","category_id":"cjuowpbs40014ja6jplwzm5ur","_id":"cjuowpbsc001sja6j5tdmylb6"},{"post_id":"cjuowpbrw000uja6j28m6w8ro","category_id":"cjuowpbs7001dja6jl8wsukr5","_id":"cjuowpbsd001wja6jw4m39vp1"},{"post_id":"cjuowpbsa001oja6j9cod2vnw","category_id":"cjuowpbs40014ja6jplwzm5ur","_id":"cjuowpbse001zja6jhx4ru13s"},{"post_id":"cjuowpbry000zja6ji09yn0xq","category_id":"cjuowpbs7001dja6jl8wsukr5","_id":"cjuowpbsf0022ja6julx0r4zd"},{"post_id":"cjuowpbsb001rja6j4083eahe","category_id":"cjuowpbs40014ja6jplwzm5ur","_id":"cjuowpbsf0023ja6jpjoaicrf"},{"post_id":"cjuowpbs40016ja6jsisbmgrj","category_id":"cjuowpbsc001tja6jmzfg4y7u","_id":"cjuowpbsf0025ja6jz1la55ew"},{"post_id":"cjuowpbs6001cja6jiwrvpuol","category_id":"cjuowpbsf0020ja6ja8mwc4l0","_id":"cjuowpbsg0029ja6j3zavel2w"},{"post_id":"cjuowpbs8001jja6jy2ehhvr2","category_id":"cjuowpbsf0020ja6ja8mwc4l0","_id":"cjuowpbsh002dja6j9a1enl2s"},{"post_id":"cjuowpbsd001vja6j24ehzvgs","category_id":"cjuowpbsg0028ja6jkwsduk8r","_id":"cjuowpbsi002hja6jdby6j8r0"},{"post_id":"cjuowpbse001yja6jjqs6qtvs","category_id":"cjuowpbsg0028ja6jkwsduk8r","_id":"cjuowpbsi002kja6jcltig88x"}],"PostTag":[{"post_id":"cjuowpbrf0007ja6jkmn1pmpo","tag_id":"cjuowpbrd0005ja6jfk5a071x","_id":"cjuowpbrj000bja6jrbpc5a5s"},{"post_id":"cjuowpbr50001ja6j6fy7yz6h","tag_id":"cjuowpbrd0005ja6jfk5a071x","_id":"cjuowpbrm000dja6juc5x29vw"},{"post_id":"cjuowpbrk000cja6jksjy6ihu","tag_id":"cjuowpbrd0005ja6jfk5a071x","_id":"cjuowpbrp000ija6jz51i8uqh"},{"post_id":"cjuowpbra0003ja6jxwls6gvt","tag_id":"cjuowpbrh000aja6jj9bkaikr","_id":"cjuowpbrr000lja6jrhhojw2u"},{"post_id":"cjuowpbrn000eja6j6lqy358e","tag_id":"cjuowpbrh000aja6jj9bkaikr","_id":"cjuowpbrt000qja6ju5zukuyd"},{"post_id":"cjuowpbrq000jja6j1rtqa0cp","tag_id":"cjuowpbrh000aja6jj9bkaikr","_id":"cjuowpbrw000tja6jemagippr"},{"post_id":"cjuowpbre0006ja6jvniwrhsw","tag_id":"cjuowpbrp000hja6jx1lnp9v7","_id":"cjuowpbrx000yja6jf65db9zx"},{"post_id":"cjuowpbrg0008ja6jkawymq64","tag_id":"cjuowpbrh000aja6jj9bkaikr","_id":"cjuowpbs30011ja6jsgda28x5"},{"post_id":"cjuowpbrr000mja6jh80c124t","tag_id":"cjuowpbrx000xja6jl3j01lcr","_id":"cjuowpbs50018ja6jeecrm4eu"},{"post_id":"cjuowpbs30012ja6j0hngohmo","tag_id":"cjuowpbrx000xja6jl3j01lcr","_id":"cjuowpbs6001aja6jpfs0ng9t"},{"post_id":"cjuowpbs50019ja6jjfkf8ne3","tag_id":"cjuowpbrx000xja6jl3j01lcr","_id":"cjuowpbs7001fja6j9zxbb89f"},{"post_id":"cjuowpbru000rja6jf9zi0qgi","tag_id":"cjuowpbs40015ja6jilkm4ixq","_id":"cjuowpbs8001ija6jinjsiiiq"},{"post_id":"cjuowpbs8001hja6j80y5ojg4","tag_id":"cjuowpbs40015ja6jilkm4ixq","_id":"cjuowpbsa001nja6jysdqg2aa"},{"post_id":"cjuowpbrw000uja6j28m6w8ro","tag_id":"cjuowpbs7001eja6jonggwkb9","_id":"cjuowpbsb001qja6jx2nepgov"},{"post_id":"cjuowpbry000zja6ji09yn0xq","tag_id":"cjuowpbsa001mja6ju5tgchx7","_id":"cjuowpbsd001xja6j4elyj9fl"},{"post_id":"cjuowpbs40016ja6jsisbmgrj","tag_id":"cjuowpbsc001uja6jiqjg5dc3","_id":"cjuowpbsg0027ja6jj4k2scbs"},{"post_id":"cjuowpbs40016ja6jsisbmgrj","tag_id":"cjuowpbsf0021ja6jfvt52gob","_id":"cjuowpbsg002aja6jrib6aieq"},{"post_id":"cjuowpbs6001cja6jiwrvpuol","tag_id":"cjuowpbsf0026ja6jg8fh5405","_id":"cjuowpbsh002cja6jmh03k1at"},{"post_id":"cjuowpbs8001jja6jy2ehhvr2","tag_id":"cjuowpbsf0026ja6jg8fh5405","_id":"cjuowpbsi002gja6jwr0mckhg"},{"post_id":"cjuowpbsa001oja6j9cod2vnw","tag_id":"cjuowpbsh002fja6j2gndwjfd","_id":"cjuowpbsi002jja6j818tjfhy"},{"post_id":"cjuowpbsb001rja6j4083eahe","tag_id":"cjuowpbsi002ija6jwx6xxhwj","_id":"cjuowpbsi002mja6j3m46917c"},{"post_id":"cjuowpbsd001vja6j24ehzvgs","tag_id":"cjuowpbsi002lja6joc46roph","_id":"cjuowpbsj002oja6jwnxl2msf"},{"post_id":"cjuowpbse001yja6jjqs6qtvs","tag_id":"cjuowpbsi002lja6joc46roph","_id":"cjuowpbsj002pja6jxkchgnoy"}],"Tag":[{"name":"你不知道的JavaScript","_id":"cjuowpbrd0005ja6jfk5a071x"},{"name":"TypeScript","_id":"cjuowpbrh000aja6jj9bkaikr"},{"name":"Node.js","_id":"cjuowpbrp000hja6jx1lnp9v7"},{"name":"JavaScript","_id":"cjuowpbrx000xja6jl3j01lcr"},{"name":"vue","_id":"cjuowpbs40015ja6jilkm4ixq"},{"name":"随笔","_id":"cjuowpbs7001eja6jonggwkb9"},{"name":"github","_id":"cjuowpbsa001mja6ju5tgchx7"},{"name":"wx.chooseWXPay","_id":"cjuowpbsc001uja6jiqjg5dc3"},{"name":"Alipay","_id":"cjuowpbsf0021ja6jfvt52gob"},{"name":"React","_id":"cjuowpbsf0026ja6jg8fh5405"},{"name":"vue-router","_id":"cjuowpbsh002fja6j2gndwjfd"},{"name":"vuex","_id":"cjuowpbsi002ija6jwx6xxhwj"},{"name":"小程序","_id":"cjuowpbsi002lja6joc46roph"}]}}